// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_messages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_messages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_messages_2eproto;
namespace rsh {
namespace protocol {
class ArgumentContext;
struct ArgumentContextDefaultTypeInternal;
extern ArgumentContextDefaultTypeInternal _ArgumentContext_default_instance_;
class CallContext;
struct CallContextDefaultTypeInternal;
extern CallContextDefaultTypeInternal _CallContext_default_instance_;
class CallFeedback;
struct CallFeedbackDefaultTypeInternal;
extern CallFeedbackDefaultTypeInternal _CallFeedback_default_instance_;
class CompileRequest;
struct CompileRequestDefaultTypeInternal;
extern CompileRequestDefaultTypeInternal _CompileRequest_default_instance_;
class CompileResponse;
struct CompileResponseDefaultTypeInternal;
extern CompileResponseDefaultTypeInternal _CompileResponse_default_instance_;
class Context;
struct ContextDefaultTypeInternal;
extern ContextDefaultTypeInternal _Context_default_instance_;
class ContextRequest;
struct ContextRequestDefaultTypeInternal;
extern ContextRequestDefaultTypeInternal _ContextRequest_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class Environment;
struct EnvironmentDefaultTypeInternal;
extern EnvironmentDefaultTypeInternal _Environment_default_instance_;
class Environment_ValuesEntry_DoNotUse;
struct Environment_ValuesEntry_DoNotUseDefaultTypeInternal;
extern Environment_ValuesEntry_DoNotUseDefaultTypeInternal _Environment_ValuesEntry_DoNotUse_default_instance_;
class FeedbackRequest;
struct FeedbackRequestDefaultTypeInternal;
extern FeedbackRequestDefaultTypeInternal _FeedbackRequest_default_instance_;
class Function;
struct FunctionDefaultTypeInternal;
extern FunctionDefaultTypeInternal _Function_default_instance_;
class FunctionRequest;
struct FunctionRequestDefaultTypeInternal;
extern FunctionRequestDefaultTypeInternal _FunctionRequest_default_instance_;
class InitRequest;
struct InitRequestDefaultTypeInternal;
extern InitRequestDefaultTypeInternal _InitRequest_default_instance_;
class InitResponse;
struct InitResponseDefaultTypeInternal;
extern InitResponseDefaultTypeInternal _InitResponse_default_instance_;
class Package;
struct PackageDefaultTypeInternal;
extern PackageDefaultTypeInternal _Package_default_instance_;
class PackageRequest;
struct PackageRequestDefaultTypeInternal;
extern PackageRequestDefaultTypeInternal _PackageRequest_default_instance_;
class PackageSource;
struct PackageSourceDefaultTypeInternal;
extern PackageSourceDefaultTypeInternal _PackageSource_default_instance_;
class TestFeedback;
struct TestFeedbackDefaultTypeInternal;
extern TestFeedbackDefaultTypeInternal _TestFeedback_default_instance_;
class TypeFeedback;
struct TypeFeedbackDefaultTypeInternal;
extern TypeFeedbackDefaultTypeInternal _TypeFeedback_default_instance_;
class TypeFeedback_Feedback;
struct TypeFeedback_FeedbackDefaultTypeInternal;
extern TypeFeedback_FeedbackDefaultTypeInternal _TypeFeedback_Feedback_default_instance_;
class TypeFeedback_TypesEntry_DoNotUse;
struct TypeFeedback_TypesEntry_DoNotUseDefaultTypeInternal;
extern TypeFeedback_TypesEntry_DoNotUseDefaultTypeInternal _TypeFeedback_TypesEntry_DoNotUse_default_instance_;
class Value;
struct ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class ValueFeedback;
struct ValueFeedbackDefaultTypeInternal;
extern ValueFeedbackDefaultTypeInternal _ValueFeedback_default_instance_;
class ValueRequest;
struct ValueRequestDefaultTypeInternal;
extern ValueRequestDefaultTypeInternal _ValueRequest_default_instance_;
class Values;
struct ValuesDefaultTypeInternal;
extern ValuesDefaultTypeInternal _Values_default_instance_;
class Version;
struct VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
}  // namespace protocol
}  // namespace rsh
PROTOBUF_NAMESPACE_OPEN
template<> ::rsh::protocol::ArgumentContext* Arena::CreateMaybeMessage<::rsh::protocol::ArgumentContext>(Arena*);
template<> ::rsh::protocol::CallContext* Arena::CreateMaybeMessage<::rsh::protocol::CallContext>(Arena*);
template<> ::rsh::protocol::CallFeedback* Arena::CreateMaybeMessage<::rsh::protocol::CallFeedback>(Arena*);
template<> ::rsh::protocol::CompileRequest* Arena::CreateMaybeMessage<::rsh::protocol::CompileRequest>(Arena*);
template<> ::rsh::protocol::CompileResponse* Arena::CreateMaybeMessage<::rsh::protocol::CompileResponse>(Arena*);
template<> ::rsh::protocol::Context* Arena::CreateMaybeMessage<::rsh::protocol::Context>(Arena*);
template<> ::rsh::protocol::ContextRequest* Arena::CreateMaybeMessage<::rsh::protocol::ContextRequest>(Arena*);
template<> ::rsh::protocol::Empty* Arena::CreateMaybeMessage<::rsh::protocol::Empty>(Arena*);
template<> ::rsh::protocol::Environment* Arena::CreateMaybeMessage<::rsh::protocol::Environment>(Arena*);
template<> ::rsh::protocol::Environment_ValuesEntry_DoNotUse* Arena::CreateMaybeMessage<::rsh::protocol::Environment_ValuesEntry_DoNotUse>(Arena*);
template<> ::rsh::protocol::FeedbackRequest* Arena::CreateMaybeMessage<::rsh::protocol::FeedbackRequest>(Arena*);
template<> ::rsh::protocol::Function* Arena::CreateMaybeMessage<::rsh::protocol::Function>(Arena*);
template<> ::rsh::protocol::FunctionRequest* Arena::CreateMaybeMessage<::rsh::protocol::FunctionRequest>(Arena*);
template<> ::rsh::protocol::InitRequest* Arena::CreateMaybeMessage<::rsh::protocol::InitRequest>(Arena*);
template<> ::rsh::protocol::InitResponse* Arena::CreateMaybeMessage<::rsh::protocol::InitResponse>(Arena*);
template<> ::rsh::protocol::Package* Arena::CreateMaybeMessage<::rsh::protocol::Package>(Arena*);
template<> ::rsh::protocol::PackageRequest* Arena::CreateMaybeMessage<::rsh::protocol::PackageRequest>(Arena*);
template<> ::rsh::protocol::PackageSource* Arena::CreateMaybeMessage<::rsh::protocol::PackageSource>(Arena*);
template<> ::rsh::protocol::TestFeedback* Arena::CreateMaybeMessage<::rsh::protocol::TestFeedback>(Arena*);
template<> ::rsh::protocol::TypeFeedback* Arena::CreateMaybeMessage<::rsh::protocol::TypeFeedback>(Arena*);
template<> ::rsh::protocol::TypeFeedback_Feedback* Arena::CreateMaybeMessage<::rsh::protocol::TypeFeedback_Feedback>(Arena*);
template<> ::rsh::protocol::TypeFeedback_TypesEntry_DoNotUse* Arena::CreateMaybeMessage<::rsh::protocol::TypeFeedback_TypesEntry_DoNotUse>(Arena*);
template<> ::rsh::protocol::Value* Arena::CreateMaybeMessage<::rsh::protocol::Value>(Arena*);
template<> ::rsh::protocol::ValueFeedback* Arena::CreateMaybeMessage<::rsh::protocol::ValueFeedback>(Arena*);
template<> ::rsh::protocol::ValueRequest* Arena::CreateMaybeMessage<::rsh::protocol::ValueRequest>(Arena*);
template<> ::rsh::protocol::Values* Arena::CreateMaybeMessage<::rsh::protocol::Values>(Arena*);
template<> ::rsh::protocol::Version* Arena::CreateMaybeMessage<::rsh::protocol::Version>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace rsh {
namespace protocol {

enum Tier : int {
  BASELINE = 0,
  OPTIMIZED = 1,
  Tier_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Tier_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Tier_IsValid(int value);
constexpr Tier Tier_MIN = BASELINE;
constexpr Tier Tier_MAX = OPTIMIZED;
constexpr int Tier_ARRAYSIZE = Tier_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Tier_descriptor();
template<typename T>
inline const std::string& Tier_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Tier>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Tier_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Tier_descriptor(), enum_t_value);
}
inline bool Tier_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Tier* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Tier>(
    Tier_descriptor(), name, value);
}
enum TestLattice : int {
  BOTH = 0,
  ONLY_TRUE = 1,
  ONLY_FALSE = 2,
  NONE = 3,
  TestLattice_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TestLattice_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TestLattice_IsValid(int value);
constexpr TestLattice TestLattice_MIN = BOTH;
constexpr TestLattice TestLattice_MAX = NONE;
constexpr int TestLattice_ARRAYSIZE = TestLattice_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TestLattice_descriptor();
template<typename T>
inline const std::string& TestLattice_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TestLattice>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TestLattice_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TestLattice_descriptor(), enum_t_value);
}
inline bool TestLattice_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TestLattice* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TestLattice>(
    TestLattice_descriptor(), name, value);
}
enum Type : int {
  ANY = 0,
  INTEGER = 1,
  REAL = 2,
  Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Type_IsValid(int value);
constexpr Type Type_MIN = ANY;
constexpr Type Type_MAX = REAL;
constexpr int Type_ARRAYSIZE = Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_descriptor();
template<typename T>
inline const std::string& Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Type_descriptor(), enum_t_value);
}
inline bool Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Type>(
    Type_descriptor(), name, value);
}
// ===================================================================

class Version final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.Version) */ {
 public:
  inline Version() : Version(nullptr) {}
  ~Version() override;
  explicit PROTOBUF_CONSTEXPR Version(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Version(const Version& from);
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Version& default_instance() {
    return *internal_default_instance();
  }
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }
  inline void Swap(Version* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Version* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Version& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Version& from) {
    Version::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Version* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.Version";
  }
  protected:
  explicit Version(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMajorFieldNumber = 1,
    kMinorFieldNumber = 2,
    kPatchFieldNumber = 3,
  };
  // int32 major = 1;
  void clear_major();
  int32_t major() const;
  void set_major(int32_t value);
  private:
  int32_t _internal_major() const;
  void _internal_set_major(int32_t value);
  public:

  // int32 minor = 2;
  void clear_minor();
  int32_t minor() const;
  void set_minor(int32_t value);
  private:
  int32_t _internal_minor() const;
  void _internal_set_minor(int32_t value);
  public:

  // int32 patch = 3;
  void clear_patch();
  int32_t patch() const;
  void set_patch(int32_t value);
  private:
  int32_t _internal_patch() const;
  void _internal_set_patch(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rsh.protocol.Version)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t major_;
    int32_t minor_;
    int32_t patch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class InitRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.InitRequest) */ {
 public:
  inline InitRequest() : InitRequest(nullptr) {}
  ~InitRequest() override;
  explicit PROTOBUF_CONSTEXPR InitRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitRequest(const InitRequest& from);
  InitRequest(InitRequest&& from) noexcept
    : InitRequest() {
    *this = ::std::move(from);
  }

  inline InitRequest& operator=(const InitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitRequest& operator=(InitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitRequest* internal_default_instance() {
    return reinterpret_cast<const InitRequest*>(
               &_InitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InitRequest& a, InitRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitRequest& from) {
    InitRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.InitRequest";
  }
  protected:
  explicit InitRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageHashFieldNumber = 4,
    kPlatformFieldNumber = 3,
    kRshVersionFieldNumber = 1,
    kRVersionFieldNumber = 2,
  };
  // repeated bytes package_hash = 4;
  int package_hash_size() const;
  private:
  int _internal_package_hash_size() const;
  public:
  void clear_package_hash();
  const std::string& package_hash(int index) const;
  std::string* mutable_package_hash(int index);
  void set_package_hash(int index, const std::string& value);
  void set_package_hash(int index, std::string&& value);
  void set_package_hash(int index, const char* value);
  void set_package_hash(int index, const void* value, size_t size);
  std::string* add_package_hash();
  void add_package_hash(const std::string& value);
  void add_package_hash(std::string&& value);
  void add_package_hash(const char* value);
  void add_package_hash(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& package_hash() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_package_hash();
  private:
  const std::string& _internal_package_hash(int index) const;
  std::string* _internal_add_package_hash();
  public:

  // string platform = 3;
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // .rsh.protocol.Version Rsh_version = 1;
  bool has_rsh_version() const;
  private:
  bool _internal_has_rsh_version() const;
  public:
  void clear_rsh_version();
  const ::rsh::protocol::Version& rsh_version() const;
  PROTOBUF_NODISCARD ::rsh::protocol::Version* release_rsh_version();
  ::rsh::protocol::Version* mutable_rsh_version();
  void set_allocated_rsh_version(::rsh::protocol::Version* rsh_version);
  private:
  const ::rsh::protocol::Version& _internal_rsh_version() const;
  ::rsh::protocol::Version* _internal_mutable_rsh_version();
  public:
  void unsafe_arena_set_allocated_rsh_version(
      ::rsh::protocol::Version* rsh_version);
  ::rsh::protocol::Version* unsafe_arena_release_rsh_version();

  // .rsh.protocol.Version R_version = 2;
  bool has_r_version() const;
  private:
  bool _internal_has_r_version() const;
  public:
  void clear_r_version();
  const ::rsh::protocol::Version& r_version() const;
  PROTOBUF_NODISCARD ::rsh::protocol::Version* release_r_version();
  ::rsh::protocol::Version* mutable_r_version();
  void set_allocated_r_version(::rsh::protocol::Version* r_version);
  private:
  const ::rsh::protocol::Version& _internal_r_version() const;
  ::rsh::protocol::Version* _internal_mutable_r_version();
  public:
  void unsafe_arena_set_allocated_r_version(
      ::rsh::protocol::Version* r_version);
  ::rsh::protocol::Version* unsafe_arena_release_r_version();

  // @@protoc_insertion_point(class_scope:rsh.protocol.InitRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> package_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
    ::rsh::protocol::Version* rsh_version_;
    ::rsh::protocol::Version* r_version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class InitResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:rsh.protocol.InitResponse) */ {
 public:
  inline InitResponse() : InitResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR InitResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitResponse(const InitResponse& from);
  InitResponse(InitResponse&& from) noexcept
    : InitResponse() {
    *this = ::std::move(from);
  }

  inline InitResponse& operator=(const InitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitResponse& operator=(InitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitResponse* internal_default_instance() {
    return reinterpret_cast<const InitResponse*>(
               &_InitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InitResponse& a, InitResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InitResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InitResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InitResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.InitResponse";
  }
  protected:
  explicit InitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rsh.protocol.InitResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class CompileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.CompileRequest) */ {
 public:
  inline CompileRequest() : CompileRequest(nullptr) {}
  ~CompileRequest() override;
  explicit PROTOBUF_CONSTEXPR CompileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompileRequest(const CompileRequest& from);
  CompileRequest(CompileRequest&& from) noexcept
    : CompileRequest() {
    *this = ::std::move(from);
  }

  inline CompileRequest& operator=(const CompileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompileRequest& operator=(CompileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompileRequest* internal_default_instance() {
    return reinterpret_cast<const CompileRequest*>(
               &_CompileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CompileRequest& a, CompileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CompileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompileRequest& from) {
    CompileRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.CompileRequest";
  }
  protected:
  explicit CompileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFunctionFieldNumber = 2,
    kContextFieldNumber = 7,
    kEnvironmentFieldNumber = 8,
    kTierFieldNumber = 4,
    kCcOptFieldNumber = 5,
    kBcOptFieldNumber = 6,
  };
  // .rsh.protocol.Function function = 2;
  bool has_function() const;
  private:
  bool _internal_has_function() const;
  public:
  void clear_function();
  const ::rsh::protocol::Function& function() const;
  PROTOBUF_NODISCARD ::rsh::protocol::Function* release_function();
  ::rsh::protocol::Function* mutable_function();
  void set_allocated_function(::rsh::protocol::Function* function);
  private:
  const ::rsh::protocol::Function& _internal_function() const;
  ::rsh::protocol::Function* _internal_mutable_function();
  public:
  void unsafe_arena_set_allocated_function(
      ::rsh::protocol::Function* function);
  ::rsh::protocol::Function* unsafe_arena_release_function();

  // optional .rsh.protocol.Context context = 7;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::rsh::protocol::Context& context() const;
  PROTOBUF_NODISCARD ::rsh::protocol::Context* release_context();
  ::rsh::protocol::Context* mutable_context();
  void set_allocated_context(::rsh::protocol::Context* context);
  private:
  const ::rsh::protocol::Context& _internal_context() const;
  ::rsh::protocol::Context* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::rsh::protocol::Context* context);
  ::rsh::protocol::Context* unsafe_arena_release_context();

  // optional .rsh.protocol.Environment environment = 8;
  bool has_environment() const;
  private:
  bool _internal_has_environment() const;
  public:
  void clear_environment();
  const ::rsh::protocol::Environment& environment() const;
  PROTOBUF_NODISCARD ::rsh::protocol::Environment* release_environment();
  ::rsh::protocol::Environment* mutable_environment();
  void set_allocated_environment(::rsh::protocol::Environment* environment);
  private:
  const ::rsh::protocol::Environment& _internal_environment() const;
  ::rsh::protocol::Environment* _internal_mutable_environment();
  public:
  void unsafe_arena_set_allocated_environment(
      ::rsh::protocol::Environment* environment);
  ::rsh::protocol::Environment* unsafe_arena_release_environment();

  // optional .rsh.protocol.Tier tier = 4;
  bool has_tier() const;
  private:
  bool _internal_has_tier() const;
  public:
  void clear_tier();
  ::rsh::protocol::Tier tier() const;
  void set_tier(::rsh::protocol::Tier value);
  private:
  ::rsh::protocol::Tier _internal_tier() const;
  void _internal_set_tier(::rsh::protocol::Tier value);
  public:

  // optional int32 cc_opt = 5;
  bool has_cc_opt() const;
  private:
  bool _internal_has_cc_opt() const;
  public:
  void clear_cc_opt();
  int32_t cc_opt() const;
  void set_cc_opt(int32_t value);
  private:
  int32_t _internal_cc_opt() const;
  void _internal_set_cc_opt(int32_t value);
  public:

  // optional int32 bc_opt = 6;
  bool has_bc_opt() const;
  private:
  bool _internal_has_bc_opt() const;
  public:
  void clear_bc_opt();
  int32_t bc_opt() const;
  void set_bc_opt(int32_t value);
  private:
  int32_t _internal_bc_opt() const;
  void _internal_set_bc_opt(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rsh.protocol.CompileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::rsh::protocol::Function* function_;
    ::rsh::protocol::Context* context_;
    ::rsh::protocol::Environment* environment_;
    int tier_;
    int32_t cc_opt_;
    int32_t bc_opt_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class CompileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.CompileResponse) */ {
 public:
  inline CompileResponse() : CompileResponse(nullptr) {}
  ~CompileResponse() override;
  explicit PROTOBUF_CONSTEXPR CompileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompileResponse(const CompileResponse& from);
  CompileResponse(CompileResponse&& from) noexcept
    : CompileResponse() {
    *this = ::std::move(from);
  }

  inline CompileResponse& operator=(const CompileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompileResponse& operator=(CompileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompileResponse* internal_default_instance() {
    return reinterpret_cast<const CompileResponse*>(
               &_CompileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CompileResponse& a, CompileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CompileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompileResponse& from) {
    CompileResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.CompileResponse";
  }
  protected:
  explicit CompileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 3,
    kConstantsFieldNumber = 4,
    kHashFieldNumber = 1,
    kTierFieldNumber = 2,
  };
  // optional bytes code = 3;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // optional bytes constants = 4;
  bool has_constants() const;
  private:
  bool _internal_has_constants() const;
  public:
  void clear_constants();
  const std::string& constants() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_constants(ArgT0&& arg0, ArgT... args);
  std::string* mutable_constants();
  PROTOBUF_NODISCARD std::string* release_constants();
  void set_allocated_constants(std::string* constants);
  private:
  const std::string& _internal_constants() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_constants(const std::string& value);
  std::string* _internal_mutable_constants();
  public:

  // uint64 hash = 1;
  void clear_hash();
  uint64_t hash() const;
  void set_hash(uint64_t value);
  private:
  uint64_t _internal_hash() const;
  void _internal_set_hash(uint64_t value);
  public:

  // .rsh.protocol.Tier tier = 2;
  void clear_tier();
  ::rsh::protocol::Tier tier() const;
  void set_tier(::rsh::protocol::Tier value);
  private:
  ::rsh::protocol::Tier _internal_tier() const;
  void _internal_set_tier(::rsh::protocol::Tier value);
  public:

  // @@protoc_insertion_point(class_scope:rsh.protocol.CompileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr constants_;
    uint64_t hash_;
    int tier_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Function final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.Function) */ {
 public:
  inline Function() : Function(nullptr) {}
  ~Function() override;
  explicit PROTOBUF_CONSTEXPR Function(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Function(const Function& from);
  Function(Function&& from) noexcept
    : Function() {
    *this = ::std::move(from);
  }

  inline Function& operator=(const Function& from) {
    CopyFrom(from);
    return *this;
  }
  inline Function& operator=(Function&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Function& default_instance() {
    return *internal_default_instance();
  }
  static inline const Function* internal_default_instance() {
    return reinterpret_cast<const Function*>(
               &_Function_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Function& a, Function& b) {
    a.Swap(&b);
  }
  inline void Swap(Function* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Function* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Function* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Function>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Function& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Function& from) {
    Function::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Function* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.Function";
  }
  protected:
  explicit Function(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kBodyFieldNumber = 4,
    kPackageHashFieldNumber = 1,
    kHashFieldNumber = 3,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bytes body = 4;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // uint64 package_hash = 1;
  void clear_package_hash();
  uint64_t package_hash() const;
  void set_package_hash(uint64_t value);
  private:
  uint64_t _internal_package_hash() const;
  void _internal_set_package_hash(uint64_t value);
  public:

  // uint64 hash = 3;
  void clear_hash();
  uint64_t hash() const;
  void set_hash(uint64_t value);
  private:
  uint64_t _internal_hash() const;
  void _internal_set_hash(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rsh.protocol.Function)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
    uint64_t package_hash_;
    uint64_t hash_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FunctionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.FunctionRequest) */ {
 public:
  inline FunctionRequest() : FunctionRequest(nullptr) {}
  ~FunctionRequest() override;
  explicit PROTOBUF_CONSTEXPR FunctionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FunctionRequest(const FunctionRequest& from);
  FunctionRequest(FunctionRequest&& from) noexcept
    : FunctionRequest() {
    *this = ::std::move(from);
  }

  inline FunctionRequest& operator=(const FunctionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionRequest& operator=(FunctionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunctionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FunctionRequest* internal_default_instance() {
    return reinterpret_cast<const FunctionRequest*>(
               &_FunctionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FunctionRequest& a, FunctionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunctionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FunctionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FunctionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FunctionRequest& from) {
    FunctionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.FunctionRequest";
  }
  protected:
  explicit FunctionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
  };
  // uint64 hash = 1;
  void clear_hash();
  uint64_t hash() const;
  void set_hash(uint64_t value);
  private:
  uint64_t _internal_hash() const;
  void _internal_set_hash(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rsh.protocol.FunctionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Environment_ValuesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Environment_ValuesEntry_DoNotUse, 
    std::string, uint64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Environment_ValuesEntry_DoNotUse, 
    std::string, uint64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> SuperType;
  Environment_ValuesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Environment_ValuesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Environment_ValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Environment_ValuesEntry_DoNotUse& other);
  static const Environment_ValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Environment_ValuesEntry_DoNotUse*>(&_Environment_ValuesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "rsh.protocol.Environment.ValuesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_messages_2eproto;
};

// -------------------------------------------------------------------

class Environment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.Environment) */ {
 public:
  inline Environment() : Environment(nullptr) {}
  ~Environment() override;
  explicit PROTOBUF_CONSTEXPR Environment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Environment(const Environment& from);
  Environment(Environment&& from) noexcept
    : Environment() {
    *this = ::std::move(from);
  }

  inline Environment& operator=(const Environment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Environment& operator=(Environment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Environment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Environment* internal_default_instance() {
    return reinterpret_cast<const Environment*>(
               &_Environment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Environment& a, Environment& b) {
    a.Swap(&b);
  }
  inline void Swap(Environment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Environment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Environment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Environment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Environment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Environment& from) {
    Environment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Environment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.Environment";
  }
  protected:
  explicit Environment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // map<string, uint64> values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >&
      _internal_values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >*
      _internal_mutable_values();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:rsh.protocol.Environment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Environment_ValuesEntry_DoNotUse,
        std::string, uint64_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ValueRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.ValueRequest) */ {
 public:
  inline ValueRequest() : ValueRequest(nullptr) {}
  ~ValueRequest() override;
  explicit PROTOBUF_CONSTEXPR ValueRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValueRequest(const ValueRequest& from);
  ValueRequest(ValueRequest&& from) noexcept
    : ValueRequest() {
    *this = ::std::move(from);
  }

  inline ValueRequest& operator=(const ValueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueRequest& operator=(ValueRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValueRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValueRequest* internal_default_instance() {
    return reinterpret_cast<const ValueRequest*>(
               &_ValueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ValueRequest& a, ValueRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ValueRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValueRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValueRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValueRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValueRequest& from) {
    ValueRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValueRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.ValueRequest";
  }
  protected:
  explicit ValueRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
  };
  // repeated uint64 hash = 1;
  int hash_size() const;
  private:
  int _internal_hash_size() const;
  public:
  void clear_hash();
  private:
  uint64_t _internal_hash(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_hash() const;
  void _internal_add_hash(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_hash();
  public:
  uint64_t hash(int index) const;
  void set_hash(int index, uint64_t value);
  void add_hash(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      hash() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_hash();

  // @@protoc_insertion_point(class_scope:rsh.protocol.ValueRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > hash_;
    mutable std::atomic<int> _hash_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Value final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  ~Value() override;
  explicit PROTOBUF_CONSTEXPR Value(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Value& default_instance() {
    return *internal_default_instance();
  }
  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Value& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Value& from) {
    Value::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Value* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.Value";
  }
  protected:
  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kHashFieldNumber = 1,
  };
  // bytes value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // uint64 hash = 1;
  void clear_hash();
  uint64_t hash() const;
  void set_hash(uint64_t value);
  private:
  uint64_t _internal_hash() const;
  void _internal_set_hash(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rsh.protocol.Value)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    uint64_t hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Values final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.Values) */ {
 public:
  inline Values() : Values(nullptr) {}
  ~Values() override;
  explicit PROTOBUF_CONSTEXPR Values(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Values(const Values& from);
  Values(Values&& from) noexcept
    : Values() {
    *this = ::std::move(from);
  }

  inline Values& operator=(const Values& from) {
    CopyFrom(from);
    return *this;
  }
  inline Values& operator=(Values&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Values& default_instance() {
    return *internal_default_instance();
  }
  static inline const Values* internal_default_instance() {
    return reinterpret_cast<const Values*>(
               &_Values_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Values& a, Values& b) {
    a.Swap(&b);
  }
  inline void Swap(Values* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Values* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Values* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Values>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Values& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Values& from) {
    Values::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Values* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.Values";
  }
  protected:
  explicit Values(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .rsh.protocol.Value values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::rsh::protocol::Value* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rsh::protocol::Value >*
      mutable_values();
  private:
  const ::rsh::protocol::Value& _internal_values(int index) const;
  ::rsh::protocol::Value* _internal_add_values();
  public:
  const ::rsh::protocol::Value& values(int index) const;
  ::rsh::protocol::Value* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rsh::protocol::Value >&
      values() const;

  // @@protoc_insertion_point(class_scope:rsh.protocol.Values)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rsh::protocol::Value > values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:rsh.protocol.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rsh.protocol.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class CallContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.CallContext) */ {
 public:
  inline CallContext() : CallContext(nullptr) {}
  ~CallContext() override;
  explicit PROTOBUF_CONSTEXPR CallContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallContext(const CallContext& from);
  CallContext(CallContext&& from) noexcept
    : CallContext() {
    *this = ::std::move(from);
  }

  inline CallContext& operator=(const CallContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallContext& operator=(CallContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallContext* internal_default_instance() {
    return reinterpret_cast<const CallContext*>(
               &_CallContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CallContext& a, CallContext& b) {
    a.Swap(&b);
  }
  inline void Swap(CallContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallContext& from) {
    CallContext::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.CallContext";
  }
  protected:
  explicit CallContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsStaticallyMatchedFieldNumber = 1,
    kCorrectNumberOfArgsFieldNumber = 2,
    kCorrectOrderOfArgsFieldNumber = 3,
    kNoMissingArgsFieldNumber = 4,
  };
  // bool args_statically_matched = 1;
  void clear_args_statically_matched();
  bool args_statically_matched() const;
  void set_args_statically_matched(bool value);
  private:
  bool _internal_args_statically_matched() const;
  void _internal_set_args_statically_matched(bool value);
  public:

  // bool correct_number_of_args = 2;
  void clear_correct_number_of_args();
  bool correct_number_of_args() const;
  void set_correct_number_of_args(bool value);
  private:
  bool _internal_correct_number_of_args() const;
  void _internal_set_correct_number_of_args(bool value);
  public:

  // bool correct_order_of_args = 3;
  void clear_correct_order_of_args();
  bool correct_order_of_args() const;
  void set_correct_order_of_args(bool value);
  private:
  bool _internal_correct_order_of_args() const;
  void _internal_set_correct_order_of_args(bool value);
  public:

  // bool no_missing_args = 4;
  void clear_no_missing_args();
  bool no_missing_args() const;
  void set_no_missing_args(bool value);
  private:
  bool _internal_no_missing_args() const;
  void _internal_set_no_missing_args(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rsh.protocol.CallContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool args_statically_matched_;
    bool correct_number_of_args_;
    bool correct_order_of_args_;
    bool no_missing_args_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ArgumentContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.ArgumentContext) */ {
 public:
  inline ArgumentContext() : ArgumentContext(nullptr) {}
  ~ArgumentContext() override;
  explicit PROTOBUF_CONSTEXPR ArgumentContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArgumentContext(const ArgumentContext& from);
  ArgumentContext(ArgumentContext&& from) noexcept
    : ArgumentContext() {
    *this = ::std::move(from);
  }

  inline ArgumentContext& operator=(const ArgumentContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArgumentContext& operator=(ArgumentContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArgumentContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArgumentContext* internal_default_instance() {
    return reinterpret_cast<const ArgumentContext*>(
               &_ArgumentContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ArgumentContext& a, ArgumentContext& b) {
    a.Swap(&b);
  }
  inline void Swap(ArgumentContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArgumentContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArgumentContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArgumentContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArgumentContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArgumentContext& from) {
    ArgumentContext::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArgumentContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.ArgumentContext";
  }
  protected:
  explicit ArgumentContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEagerFieldNumber = 1,
    kReflectionFieldNumber = 2,
    kObjectFieldNumber = 3,
    kTypeFieldNumber = 4,
  };
  // bool eager = 1;
  void clear_eager();
  bool eager() const;
  void set_eager(bool value);
  private:
  bool _internal_eager() const;
  void _internal_set_eager(bool value);
  public:

  // bool reflection = 2;
  void clear_reflection();
  bool reflection() const;
  void set_reflection(bool value);
  private:
  bool _internal_reflection() const;
  void _internal_set_reflection(bool value);
  public:

  // bool object = 3;
  void clear_object();
  bool object() const;
  void set_object(bool value);
  private:
  bool _internal_object() const;
  void _internal_set_object(bool value);
  public:

  // optional .rsh.protocol.Type type = 4;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::rsh::protocol::Type type() const;
  void set_type(::rsh::protocol::Type value);
  private:
  ::rsh::protocol::Type _internal_type() const;
  void _internal_set_type(::rsh::protocol::Type value);
  public:

  // @@protoc_insertion_point(class_scope:rsh.protocol.ArgumentContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool eager_;
    bool reflection_;
    bool object_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Context final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.Context) */ {
 public:
  inline Context() : Context(nullptr) {}
  ~Context() override;
  explicit PROTOBUF_CONSTEXPR Context(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Context(const Context& from);
  Context(Context&& from) noexcept
    : Context() {
    *this = ::std::move(from);
  }

  inline Context& operator=(const Context& from) {
    CopyFrom(from);
    return *this;
  }
  inline Context& operator=(Context&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Context& default_instance() {
    return *internal_default_instance();
  }
  static inline const Context* internal_default_instance() {
    return reinterpret_cast<const Context*>(
               &_Context_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Context& a, Context& b) {
    a.Swap(&b);
  }
  inline void Swap(Context* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Context* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Context* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Context>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Context& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Context& from) {
    Context::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Context* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.Context";
  }
  protected:
  explicit Context(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentContextFieldNumber = 2,
    kCallContextFieldNumber = 1,
  };
  // repeated .rsh.protocol.ArgumentContext argument_context = 2;
  int argument_context_size() const;
  private:
  int _internal_argument_context_size() const;
  public:
  void clear_argument_context();
  ::rsh::protocol::ArgumentContext* mutable_argument_context(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rsh::protocol::ArgumentContext >*
      mutable_argument_context();
  private:
  const ::rsh::protocol::ArgumentContext& _internal_argument_context(int index) const;
  ::rsh::protocol::ArgumentContext* _internal_add_argument_context();
  public:
  const ::rsh::protocol::ArgumentContext& argument_context(int index) const;
  ::rsh::protocol::ArgumentContext* add_argument_context();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rsh::protocol::ArgumentContext >&
      argument_context() const;

  // .rsh.protocol.CallContext call_context = 1;
  bool has_call_context() const;
  private:
  bool _internal_has_call_context() const;
  public:
  void clear_call_context();
  const ::rsh::protocol::CallContext& call_context() const;
  PROTOBUF_NODISCARD ::rsh::protocol::CallContext* release_call_context();
  ::rsh::protocol::CallContext* mutable_call_context();
  void set_allocated_call_context(::rsh::protocol::CallContext* call_context);
  private:
  const ::rsh::protocol::CallContext& _internal_call_context() const;
  ::rsh::protocol::CallContext* _internal_mutable_call_context();
  public:
  void unsafe_arena_set_allocated_call_context(
      ::rsh::protocol::CallContext* call_context);
  ::rsh::protocol::CallContext* unsafe_arena_release_call_context();

  // @@protoc_insertion_point(class_scope:rsh.protocol.Context)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rsh::protocol::ArgumentContext > argument_context_;
    ::rsh::protocol::CallContext* call_context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ContextRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.ContextRequest) */ {
 public:
  inline ContextRequest() : ContextRequest(nullptr) {}
  ~ContextRequest() override;
  explicit PROTOBUF_CONSTEXPR ContextRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContextRequest(const ContextRequest& from);
  ContextRequest(ContextRequest&& from) noexcept
    : ContextRequest() {
    *this = ::std::move(from);
  }

  inline ContextRequest& operator=(const ContextRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContextRequest& operator=(ContextRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContextRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContextRequest* internal_default_instance() {
    return reinterpret_cast<const ContextRequest*>(
               &_ContextRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ContextRequest& a, ContextRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ContextRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContextRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContextRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContextRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContextRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContextRequest& from) {
    ContextRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContextRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.ContextRequest";
  }
  protected:
  explicit ContextRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFunctionFieldNumber = 1,
  };
  // .rsh.protocol.Function function = 1;
  bool has_function() const;
  private:
  bool _internal_has_function() const;
  public:
  void clear_function();
  const ::rsh::protocol::Function& function() const;
  PROTOBUF_NODISCARD ::rsh::protocol::Function* release_function();
  ::rsh::protocol::Function* mutable_function();
  void set_allocated_function(::rsh::protocol::Function* function);
  private:
  const ::rsh::protocol::Function& _internal_function() const;
  ::rsh::protocol::Function* _internal_mutable_function();
  public:
  void unsafe_arena_set_allocated_function(
      ::rsh::protocol::Function* function);
  ::rsh::protocol::Function* unsafe_arena_release_function();

  // @@protoc_insertion_point(class_scope:rsh.protocol.ContextRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::rsh::protocol::Function* function_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class TestFeedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.TestFeedback) */ {
 public:
  inline TestFeedback() : TestFeedback(nullptr) {}
  ~TestFeedback() override;
  explicit PROTOBUF_CONSTEXPR TestFeedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestFeedback(const TestFeedback& from);
  TestFeedback(TestFeedback&& from) noexcept
    : TestFeedback() {
    *this = ::std::move(from);
  }

  inline TestFeedback& operator=(const TestFeedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestFeedback& operator=(TestFeedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestFeedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestFeedback* internal_default_instance() {
    return reinterpret_cast<const TestFeedback*>(
               &_TestFeedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TestFeedback& a, TestFeedback& b) {
    a.Swap(&b);
  }
  inline void Swap(TestFeedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestFeedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestFeedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestFeedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestFeedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestFeedback& from) {
    TestFeedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestFeedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.TestFeedback";
  }
  protected:
  explicit TestFeedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestLatticeFieldNumber = 1,
  };
  // .rsh.protocol.TestLattice test_lattice = 1;
  void clear_test_lattice();
  ::rsh::protocol::TestLattice test_lattice() const;
  void set_test_lattice(::rsh::protocol::TestLattice value);
  private:
  ::rsh::protocol::TestLattice _internal_test_lattice() const;
  void _internal_set_test_lattice(::rsh::protocol::TestLattice value);
  public:

  // @@protoc_insertion_point(class_scope:rsh.protocol.TestFeedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int test_lattice_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class CallFeedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.CallFeedback) */ {
 public:
  inline CallFeedback() : CallFeedback(nullptr) {}
  ~CallFeedback() override;
  explicit PROTOBUF_CONSTEXPR CallFeedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallFeedback(const CallFeedback& from);
  CallFeedback(CallFeedback&& from) noexcept
    : CallFeedback() {
    *this = ::std::move(from);
  }

  inline CallFeedback& operator=(const CallFeedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallFeedback& operator=(CallFeedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallFeedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallFeedback* internal_default_instance() {
    return reinterpret_cast<const CallFeedback*>(
               &_CallFeedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CallFeedback& a, CallFeedback& b) {
    a.Swap(&b);
  }
  inline void Swap(CallFeedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallFeedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallFeedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallFeedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallFeedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallFeedback& from) {
    CallFeedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallFeedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.CallFeedback";
  }
  protected:
  explicit CallFeedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNCallsFieldNumber = 1,
    kCalleeHashFieldNumber = 2,
  };
  // int64 n_calls = 1;
  void clear_n_calls();
  int64_t n_calls() const;
  void set_n_calls(int64_t value);
  private:
  int64_t _internal_n_calls() const;
  void _internal_set_n_calls(int64_t value);
  public:

  // uint64 callee_hash = 2;
  void clear_callee_hash();
  uint64_t callee_hash() const;
  void set_callee_hash(uint64_t value);
  private:
  uint64_t _internal_callee_hash() const;
  void _internal_set_callee_hash(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rsh.protocol.CallFeedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t n_calls_;
    uint64_t callee_hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ValueFeedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.ValueFeedback) */ {
 public:
  inline ValueFeedback() : ValueFeedback(nullptr) {}
  ~ValueFeedback() override;
  explicit PROTOBUF_CONSTEXPR ValueFeedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValueFeedback(const ValueFeedback& from);
  ValueFeedback(ValueFeedback&& from) noexcept
    : ValueFeedback() {
    *this = ::std::move(from);
  }

  inline ValueFeedback& operator=(const ValueFeedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueFeedback& operator=(ValueFeedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValueFeedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValueFeedback* internal_default_instance() {
    return reinterpret_cast<const ValueFeedback*>(
               &_ValueFeedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ValueFeedback& a, ValueFeedback& b) {
    a.Swap(&b);
  }
  inline void Swap(ValueFeedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueFeedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValueFeedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValueFeedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValueFeedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValueFeedback& from) {
    ValueFeedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValueFeedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.ValueFeedback";
  }
  protected:
  explicit ValueFeedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScalarFieldNumber = 1,
    kObjectFieldNumber = 2,
    kAccessedAttributesFieldNumber = 3,
    kVectorizableFieldNumber = 4,
    kIsPromiseFieldNumber = 5,
  };
  // bool scalar = 1;
  void clear_scalar();
  bool scalar() const;
  void set_scalar(bool value);
  private:
  bool _internal_scalar() const;
  void _internal_set_scalar(bool value);
  public:

  // bool object = 2;
  void clear_object();
  bool object() const;
  void set_object(bool value);
  private:
  bool _internal_object() const;
  void _internal_set_object(bool value);
  public:

  // bool accessed_attributes = 3;
  void clear_accessed_attributes();
  bool accessed_attributes() const;
  void set_accessed_attributes(bool value);
  private:
  bool _internal_accessed_attributes() const;
  void _internal_set_accessed_attributes(bool value);
  public:

  // bool vectorizable = 4;
  void clear_vectorizable();
  bool vectorizable() const;
  void set_vectorizable(bool value);
  private:
  bool _internal_vectorizable() const;
  void _internal_set_vectorizable(bool value);
  public:

  // bool is_promise = 5;
  void clear_is_promise();
  bool is_promise() const;
  void set_is_promise(bool value);
  private:
  bool _internal_is_promise() const;
  void _internal_set_is_promise(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rsh.protocol.ValueFeedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool scalar_;
    bool object_;
    bool accessed_attributes_;
    bool vectorizable_;
    bool is_promise_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class TypeFeedback_Feedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.TypeFeedback.Feedback) */ {
 public:
  inline TypeFeedback_Feedback() : TypeFeedback_Feedback(nullptr) {}
  ~TypeFeedback_Feedback() override;
  explicit PROTOBUF_CONSTEXPR TypeFeedback_Feedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TypeFeedback_Feedback(const TypeFeedback_Feedback& from);
  TypeFeedback_Feedback(TypeFeedback_Feedback&& from) noexcept
    : TypeFeedback_Feedback() {
    *this = ::std::move(from);
  }

  inline TypeFeedback_Feedback& operator=(const TypeFeedback_Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeFeedback_Feedback& operator=(TypeFeedback_Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeFeedback_Feedback& default_instance() {
    return *internal_default_instance();
  }
  enum FeedbackCase {
    kTestFeedback = 1,
    kCallFeedback = 2,
    kValueFeedback = 3,
    FEEDBACK_NOT_SET = 0,
  };

  static inline const TypeFeedback_Feedback* internal_default_instance() {
    return reinterpret_cast<const TypeFeedback_Feedback*>(
               &_TypeFeedback_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(TypeFeedback_Feedback& a, TypeFeedback_Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(TypeFeedback_Feedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeFeedback_Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeFeedback_Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TypeFeedback_Feedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TypeFeedback_Feedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TypeFeedback_Feedback& from) {
    TypeFeedback_Feedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TypeFeedback_Feedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.TypeFeedback.Feedback";
  }
  protected:
  explicit TypeFeedback_Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFeedbackFieldNumber = 1,
    kCallFeedbackFieldNumber = 2,
    kValueFeedbackFieldNumber = 3,
  };
  // .rsh.protocol.TestFeedback test_feedback = 1;
  bool has_test_feedback() const;
  private:
  bool _internal_has_test_feedback() const;
  public:
  void clear_test_feedback();
  const ::rsh::protocol::TestFeedback& test_feedback() const;
  PROTOBUF_NODISCARD ::rsh::protocol::TestFeedback* release_test_feedback();
  ::rsh::protocol::TestFeedback* mutable_test_feedback();
  void set_allocated_test_feedback(::rsh::protocol::TestFeedback* test_feedback);
  private:
  const ::rsh::protocol::TestFeedback& _internal_test_feedback() const;
  ::rsh::protocol::TestFeedback* _internal_mutable_test_feedback();
  public:
  void unsafe_arena_set_allocated_test_feedback(
      ::rsh::protocol::TestFeedback* test_feedback);
  ::rsh::protocol::TestFeedback* unsafe_arena_release_test_feedback();

  // .rsh.protocol.CallFeedback call_feedback = 2;
  bool has_call_feedback() const;
  private:
  bool _internal_has_call_feedback() const;
  public:
  void clear_call_feedback();
  const ::rsh::protocol::CallFeedback& call_feedback() const;
  PROTOBUF_NODISCARD ::rsh::protocol::CallFeedback* release_call_feedback();
  ::rsh::protocol::CallFeedback* mutable_call_feedback();
  void set_allocated_call_feedback(::rsh::protocol::CallFeedback* call_feedback);
  private:
  const ::rsh::protocol::CallFeedback& _internal_call_feedback() const;
  ::rsh::protocol::CallFeedback* _internal_mutable_call_feedback();
  public:
  void unsafe_arena_set_allocated_call_feedback(
      ::rsh::protocol::CallFeedback* call_feedback);
  ::rsh::protocol::CallFeedback* unsafe_arena_release_call_feedback();

  // .rsh.protocol.ValueFeedback value_feedback = 3;
  bool has_value_feedback() const;
  private:
  bool _internal_has_value_feedback() const;
  public:
  void clear_value_feedback();
  const ::rsh::protocol::ValueFeedback& value_feedback() const;
  PROTOBUF_NODISCARD ::rsh::protocol::ValueFeedback* release_value_feedback();
  ::rsh::protocol::ValueFeedback* mutable_value_feedback();
  void set_allocated_value_feedback(::rsh::protocol::ValueFeedback* value_feedback);
  private:
  const ::rsh::protocol::ValueFeedback& _internal_value_feedback() const;
  ::rsh::protocol::ValueFeedback* _internal_mutable_value_feedback();
  public:
  void unsafe_arena_set_allocated_value_feedback(
      ::rsh::protocol::ValueFeedback* value_feedback);
  ::rsh::protocol::ValueFeedback* unsafe_arena_release_value_feedback();

  void clear_feedback();
  FeedbackCase feedback_case() const;
  // @@protoc_insertion_point(class_scope:rsh.protocol.TypeFeedback.Feedback)
 private:
  class _Internal;
  void set_has_test_feedback();
  void set_has_call_feedback();
  void set_has_value_feedback();

  inline bool has_feedback() const;
  inline void clear_has_feedback();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union FeedbackUnion {
      constexpr FeedbackUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::rsh::protocol::TestFeedback* test_feedback_;
      ::rsh::protocol::CallFeedback* call_feedback_;
      ::rsh::protocol::ValueFeedback* value_feedback_;
    } feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class TypeFeedback_TypesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TypeFeedback_TypesEntry_DoNotUse, 
    int64_t, ::rsh::protocol::TypeFeedback_Feedback,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TypeFeedback_TypesEntry_DoNotUse, 
    int64_t, ::rsh::protocol::TypeFeedback_Feedback,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TypeFeedback_TypesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TypeFeedback_TypesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TypeFeedback_TypesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TypeFeedback_TypesEntry_DoNotUse& other);
  static const TypeFeedback_TypesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TypeFeedback_TypesEntry_DoNotUse*>(&_TypeFeedback_TypesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_messages_2eproto;
};

// -------------------------------------------------------------------

class TypeFeedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.TypeFeedback) */ {
 public:
  inline TypeFeedback() : TypeFeedback(nullptr) {}
  ~TypeFeedback() override;
  explicit PROTOBUF_CONSTEXPR TypeFeedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TypeFeedback(const TypeFeedback& from);
  TypeFeedback(TypeFeedback&& from) noexcept
    : TypeFeedback() {
    *this = ::std::move(from);
  }

  inline TypeFeedback& operator=(const TypeFeedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeFeedback& operator=(TypeFeedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeFeedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const TypeFeedback* internal_default_instance() {
    return reinterpret_cast<const TypeFeedback*>(
               &_TypeFeedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(TypeFeedback& a, TypeFeedback& b) {
    a.Swap(&b);
  }
  inline void Swap(TypeFeedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeFeedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeFeedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TypeFeedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TypeFeedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TypeFeedback& from) {
    TypeFeedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TypeFeedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.TypeFeedback";
  }
  protected:
  explicit TypeFeedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TypeFeedback_Feedback Feedback;

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 2,
  };
  // map<int64, .rsh.protocol.TypeFeedback.Feedback> types = 2;
  int types_size() const;
  private:
  int _internal_types_size() const;
  public:
  void clear_types();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::rsh::protocol::TypeFeedback_Feedback >&
      _internal_types() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::rsh::protocol::TypeFeedback_Feedback >*
      _internal_mutable_types();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::rsh::protocol::TypeFeedback_Feedback >&
      types() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::rsh::protocol::TypeFeedback_Feedback >*
      mutable_types();

  // @@protoc_insertion_point(class_scope:rsh.protocol.TypeFeedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TypeFeedback_TypesEntry_DoNotUse,
        int64_t, ::rsh::protocol::TypeFeedback_Feedback,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> types_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FeedbackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.FeedbackRequest) */ {
 public:
  inline FeedbackRequest() : FeedbackRequest(nullptr) {}
  ~FeedbackRequest() override;
  explicit PROTOBUF_CONSTEXPR FeedbackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedbackRequest(const FeedbackRequest& from);
  FeedbackRequest(FeedbackRequest&& from) noexcept
    : FeedbackRequest() {
    *this = ::std::move(from);
  }

  inline FeedbackRequest& operator=(const FeedbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedbackRequest& operator=(FeedbackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedbackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedbackRequest* internal_default_instance() {
    return reinterpret_cast<const FeedbackRequest*>(
               &_FeedbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(FeedbackRequest& a, FeedbackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedbackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedbackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedbackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedbackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedbackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedbackRequest& from) {
    FeedbackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedbackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.FeedbackRequest";
  }
  protected:
  explicit FeedbackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFunctionFieldNumber = 1,
  };
  // .rsh.protocol.Function function = 1;
  bool has_function() const;
  private:
  bool _internal_has_function() const;
  public:
  void clear_function();
  const ::rsh::protocol::Function& function() const;
  PROTOBUF_NODISCARD ::rsh::protocol::Function* release_function();
  ::rsh::protocol::Function* mutable_function();
  void set_allocated_function(::rsh::protocol::Function* function);
  private:
  const ::rsh::protocol::Function& _internal_function() const;
  ::rsh::protocol::Function* _internal_mutable_function();
  public:
  void unsafe_arena_set_allocated_function(
      ::rsh::protocol::Function* function);
  ::rsh::protocol::Function* unsafe_arena_release_function();

  // @@protoc_insertion_point(class_scope:rsh.protocol.FeedbackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::rsh::protocol::Function* function_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class PackageSource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.PackageSource) */ {
 public:
  inline PackageSource() : PackageSource(nullptr) {}
  ~PackageSource() override;
  explicit PROTOBUF_CONSTEXPR PackageSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PackageSource(const PackageSource& from);
  PackageSource(PackageSource&& from) noexcept
    : PackageSource() {
    *this = ::std::move(from);
  }

  inline PackageSource& operator=(const PackageSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline PackageSource& operator=(PackageSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PackageSource& default_instance() {
    return *internal_default_instance();
  }
  enum SourceCase {
    kRMirror = 2,
    kGithubUrl = 3,
    SOURCE_NOT_SET = 0,
  };

  static inline const PackageSource* internal_default_instance() {
    return reinterpret_cast<const PackageSource*>(
               &_PackageSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(PackageSource& a, PackageSource& b) {
    a.Swap(&b);
  }
  inline void Swap(PackageSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PackageSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PackageSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PackageSource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PackageSource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PackageSource& from) {
    PackageSource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PackageSource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.PackageSource";
  }
  protected:
  explicit PackageSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRMirrorFieldNumber = 2,
    kGithubUrlFieldNumber = 3,
  };
  // string r_mirror = 2;
  bool has_r_mirror() const;
  private:
  bool _internal_has_r_mirror() const;
  public:
  void clear_r_mirror();
  const std::string& r_mirror() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_r_mirror(ArgT0&& arg0, ArgT... args);
  std::string* mutable_r_mirror();
  PROTOBUF_NODISCARD std::string* release_r_mirror();
  void set_allocated_r_mirror(std::string* r_mirror);
  private:
  const std::string& _internal_r_mirror() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_r_mirror(const std::string& value);
  std::string* _internal_mutable_r_mirror();
  public:

  // string github_url = 3;
  bool has_github_url() const;
  private:
  bool _internal_has_github_url() const;
  public:
  void clear_github_url();
  const std::string& github_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_github_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_github_url();
  PROTOBUF_NODISCARD std::string* release_github_url();
  void set_allocated_github_url(std::string* github_url);
  private:
  const std::string& _internal_github_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_github_url(const std::string& value);
  std::string* _internal_mutable_github_url();
  public:

  void clear_source();
  SourceCase source_case() const;
  // @@protoc_insertion_point(class_scope:rsh.protocol.PackageSource)
 private:
  class _Internal;
  void set_has_r_mirror();
  void set_has_github_url();

  inline bool has_source() const;
  inline void clear_has_source();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union SourceUnion {
      constexpr SourceUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr r_mirror_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr github_url_;
    } source_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Package final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.Package) */ {
 public:
  inline Package() : Package(nullptr) {}
  ~Package() override;
  explicit PROTOBUF_CONSTEXPR Package(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Package(const Package& from);
  Package(Package&& from) noexcept
    : Package() {
    *this = ::std::move(from);
  }

  inline Package& operator=(const Package& from) {
    CopyFrom(from);
    return *this;
  }
  inline Package& operator=(Package&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Package& default_instance() {
    return *internal_default_instance();
  }
  static inline const Package* internal_default_instance() {
    return reinterpret_cast<const Package*>(
               &_Package_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Package& a, Package& b) {
    a.Swap(&b);
  }
  inline void Swap(Package* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Package* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Package* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Package>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Package& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Package& from) {
    Package::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Package* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.Package";
  }
  protected:
  explicit Package(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFunctionHashesFieldNumber = 4,
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kSourceFieldNumber = 5,
  };
  // repeated uint64 function_hashes = 4;
  int function_hashes_size() const;
  private:
  int _internal_function_hashes_size() const;
  public:
  void clear_function_hashes();
  private:
  uint64_t _internal_function_hashes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_function_hashes() const;
  void _internal_add_function_hashes(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_function_hashes();
  public:
  uint64_t function_hashes(int index) const;
  void set_function_hashes(int index, uint64_t value);
  void add_function_hashes(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      function_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_function_hashes();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .rsh.protocol.Version version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::rsh::protocol::Version& version() const;
  PROTOBUF_NODISCARD ::rsh::protocol::Version* release_version();
  ::rsh::protocol::Version* mutable_version();
  void set_allocated_version(::rsh::protocol::Version* version);
  private:
  const ::rsh::protocol::Version& _internal_version() const;
  ::rsh::protocol::Version* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::rsh::protocol::Version* version);
  ::rsh::protocol::Version* unsafe_arena_release_version();

  // optional .rsh.protocol.PackageSource source = 5;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::rsh::protocol::PackageSource& source() const;
  PROTOBUF_NODISCARD ::rsh::protocol::PackageSource* release_source();
  ::rsh::protocol::PackageSource* mutable_source();
  void set_allocated_source(::rsh::protocol::PackageSource* source);
  private:
  const ::rsh::protocol::PackageSource& _internal_source() const;
  ::rsh::protocol::PackageSource* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::rsh::protocol::PackageSource* source);
  ::rsh::protocol::PackageSource* unsafe_arena_release_source();

  // @@protoc_insertion_point(class_scope:rsh.protocol.Package)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > function_hashes_;
    mutable std::atomic<int> _function_hashes_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::rsh::protocol::Version* version_;
    ::rsh::protocol::PackageSource* source_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class PackageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsh.protocol.PackageRequest) */ {
 public:
  inline PackageRequest() : PackageRequest(nullptr) {}
  ~PackageRequest() override;
  explicit PROTOBUF_CONSTEXPR PackageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PackageRequest(const PackageRequest& from);
  PackageRequest(PackageRequest&& from) noexcept
    : PackageRequest() {
    *this = ::std::move(from);
  }

  inline PackageRequest& operator=(const PackageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PackageRequest& operator=(PackageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PackageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PackageRequest* internal_default_instance() {
    return reinterpret_cast<const PackageRequest*>(
               &_PackageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(PackageRequest& a, PackageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PackageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PackageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PackageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PackageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PackageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PackageRequest& from) {
    PackageRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PackageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsh.protocol.PackageRequest";
  }
  protected:
  explicit PackageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
  };
  // uint64 hash = 1;
  void clear_hash();
  uint64_t hash() const;
  void set_hash(uint64_t value);
  private:
  uint64_t _internal_hash() const;
  void _internal_set_hash(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rsh.protocol.PackageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Version

// int32 major = 1;
inline void Version::clear_major() {
  _impl_.major_ = 0;
}
inline int32_t Version::_internal_major() const {
  return _impl_.major_;
}
inline int32_t Version::major() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.Version.major)
  return _internal_major();
}
inline void Version::_internal_set_major(int32_t value) {
  
  _impl_.major_ = value;
}
inline void Version::set_major(int32_t value) {
  _internal_set_major(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.Version.major)
}

// int32 minor = 2;
inline void Version::clear_minor() {
  _impl_.minor_ = 0;
}
inline int32_t Version::_internal_minor() const {
  return _impl_.minor_;
}
inline int32_t Version::minor() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.Version.minor)
  return _internal_minor();
}
inline void Version::_internal_set_minor(int32_t value) {
  
  _impl_.minor_ = value;
}
inline void Version::set_minor(int32_t value) {
  _internal_set_minor(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.Version.minor)
}

// int32 patch = 3;
inline void Version::clear_patch() {
  _impl_.patch_ = 0;
}
inline int32_t Version::_internal_patch() const {
  return _impl_.patch_;
}
inline int32_t Version::patch() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.Version.patch)
  return _internal_patch();
}
inline void Version::_internal_set_patch(int32_t value) {
  
  _impl_.patch_ = value;
}
inline void Version::set_patch(int32_t value) {
  _internal_set_patch(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.Version.patch)
}

// -------------------------------------------------------------------

// InitRequest

// .rsh.protocol.Version Rsh_version = 1;
inline bool InitRequest::_internal_has_rsh_version() const {
  return this != internal_default_instance() && _impl_.rsh_version_ != nullptr;
}
inline bool InitRequest::has_rsh_version() const {
  return _internal_has_rsh_version();
}
inline void InitRequest::clear_rsh_version() {
  if (GetArenaForAllocation() == nullptr && _impl_.rsh_version_ != nullptr) {
    delete _impl_.rsh_version_;
  }
  _impl_.rsh_version_ = nullptr;
}
inline const ::rsh::protocol::Version& InitRequest::_internal_rsh_version() const {
  const ::rsh::protocol::Version* p = _impl_.rsh_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::rsh::protocol::Version&>(
      ::rsh::protocol::_Version_default_instance_);
}
inline const ::rsh::protocol::Version& InitRequest::rsh_version() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.InitRequest.Rsh_version)
  return _internal_rsh_version();
}
inline void InitRequest::unsafe_arena_set_allocated_rsh_version(
    ::rsh::protocol::Version* rsh_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rsh_version_);
  }
  _impl_.rsh_version_ = rsh_version;
  if (rsh_version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rsh.protocol.InitRequest.Rsh_version)
}
inline ::rsh::protocol::Version* InitRequest::release_rsh_version() {
  
  ::rsh::protocol::Version* temp = _impl_.rsh_version_;
  _impl_.rsh_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rsh::protocol::Version* InitRequest::unsafe_arena_release_rsh_version() {
  // @@protoc_insertion_point(field_release:rsh.protocol.InitRequest.Rsh_version)
  
  ::rsh::protocol::Version* temp = _impl_.rsh_version_;
  _impl_.rsh_version_ = nullptr;
  return temp;
}
inline ::rsh::protocol::Version* InitRequest::_internal_mutable_rsh_version() {
  
  if (_impl_.rsh_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::rsh::protocol::Version>(GetArenaForAllocation());
    _impl_.rsh_version_ = p;
  }
  return _impl_.rsh_version_;
}
inline ::rsh::protocol::Version* InitRequest::mutable_rsh_version() {
  ::rsh::protocol::Version* _msg = _internal_mutable_rsh_version();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.InitRequest.Rsh_version)
  return _msg;
}
inline void InitRequest::set_allocated_rsh_version(::rsh::protocol::Version* rsh_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rsh_version_;
  }
  if (rsh_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rsh_version);
    if (message_arena != submessage_arena) {
      rsh_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rsh_version, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rsh_version_ = rsh_version;
  // @@protoc_insertion_point(field_set_allocated:rsh.protocol.InitRequest.Rsh_version)
}

// .rsh.protocol.Version R_version = 2;
inline bool InitRequest::_internal_has_r_version() const {
  return this != internal_default_instance() && _impl_.r_version_ != nullptr;
}
inline bool InitRequest::has_r_version() const {
  return _internal_has_r_version();
}
inline void InitRequest::clear_r_version() {
  if (GetArenaForAllocation() == nullptr && _impl_.r_version_ != nullptr) {
    delete _impl_.r_version_;
  }
  _impl_.r_version_ = nullptr;
}
inline const ::rsh::protocol::Version& InitRequest::_internal_r_version() const {
  const ::rsh::protocol::Version* p = _impl_.r_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::rsh::protocol::Version&>(
      ::rsh::protocol::_Version_default_instance_);
}
inline const ::rsh::protocol::Version& InitRequest::r_version() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.InitRequest.R_version)
  return _internal_r_version();
}
inline void InitRequest::unsafe_arena_set_allocated_r_version(
    ::rsh::protocol::Version* r_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.r_version_);
  }
  _impl_.r_version_ = r_version;
  if (r_version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rsh.protocol.InitRequest.R_version)
}
inline ::rsh::protocol::Version* InitRequest::release_r_version() {
  
  ::rsh::protocol::Version* temp = _impl_.r_version_;
  _impl_.r_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rsh::protocol::Version* InitRequest::unsafe_arena_release_r_version() {
  // @@protoc_insertion_point(field_release:rsh.protocol.InitRequest.R_version)
  
  ::rsh::protocol::Version* temp = _impl_.r_version_;
  _impl_.r_version_ = nullptr;
  return temp;
}
inline ::rsh::protocol::Version* InitRequest::_internal_mutable_r_version() {
  
  if (_impl_.r_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::rsh::protocol::Version>(GetArenaForAllocation());
    _impl_.r_version_ = p;
  }
  return _impl_.r_version_;
}
inline ::rsh::protocol::Version* InitRequest::mutable_r_version() {
  ::rsh::protocol::Version* _msg = _internal_mutable_r_version();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.InitRequest.R_version)
  return _msg;
}
inline void InitRequest::set_allocated_r_version(::rsh::protocol::Version* r_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.r_version_;
  }
  if (r_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(r_version);
    if (message_arena != submessage_arena) {
      r_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, r_version, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.r_version_ = r_version;
  // @@protoc_insertion_point(field_set_allocated:rsh.protocol.InitRequest.R_version)
}

// string platform = 3;
inline void InitRequest::clear_platform() {
  _impl_.platform_.ClearToEmpty();
}
inline const std::string& InitRequest::platform() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.InitRequest.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitRequest::set_platform(ArgT0&& arg0, ArgT... args) {
 
 _impl_.platform_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rsh.protocol.InitRequest.platform)
}
inline std::string* InitRequest::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.InitRequest.platform)
  return _s;
}
inline const std::string& InitRequest::_internal_platform() const {
  return _impl_.platform_.Get();
}
inline void InitRequest::_internal_set_platform(const std::string& value) {
  
  _impl_.platform_.Set(value, GetArenaForAllocation());
}
inline std::string* InitRequest::_internal_mutable_platform() {
  
  return _impl_.platform_.Mutable(GetArenaForAllocation());
}
inline std::string* InitRequest::release_platform() {
  // @@protoc_insertion_point(field_release:rsh.protocol.InitRequest.platform)
  return _impl_.platform_.Release();
}
inline void InitRequest::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    
  } else {
    
  }
  _impl_.platform_.SetAllocated(platform, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.platform_.IsDefault()) {
    _impl_.platform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rsh.protocol.InitRequest.platform)
}

// repeated bytes package_hash = 4;
inline int InitRequest::_internal_package_hash_size() const {
  return _impl_.package_hash_.size();
}
inline int InitRequest::package_hash_size() const {
  return _internal_package_hash_size();
}
inline void InitRequest::clear_package_hash() {
  _impl_.package_hash_.Clear();
}
inline std::string* InitRequest::add_package_hash() {
  std::string* _s = _internal_add_package_hash();
  // @@protoc_insertion_point(field_add_mutable:rsh.protocol.InitRequest.package_hash)
  return _s;
}
inline const std::string& InitRequest::_internal_package_hash(int index) const {
  return _impl_.package_hash_.Get(index);
}
inline const std::string& InitRequest::package_hash(int index) const {
  // @@protoc_insertion_point(field_get:rsh.protocol.InitRequest.package_hash)
  return _internal_package_hash(index);
}
inline std::string* InitRequest::mutable_package_hash(int index) {
  // @@protoc_insertion_point(field_mutable:rsh.protocol.InitRequest.package_hash)
  return _impl_.package_hash_.Mutable(index);
}
inline void InitRequest::set_package_hash(int index, const std::string& value) {
  _impl_.package_hash_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.InitRequest.package_hash)
}
inline void InitRequest::set_package_hash(int index, std::string&& value) {
  _impl_.package_hash_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:rsh.protocol.InitRequest.package_hash)
}
inline void InitRequest::set_package_hash(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.package_hash_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:rsh.protocol.InitRequest.package_hash)
}
inline void InitRequest::set_package_hash(int index, const void* value, size_t size) {
  _impl_.package_hash_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rsh.protocol.InitRequest.package_hash)
}
inline std::string* InitRequest::_internal_add_package_hash() {
  return _impl_.package_hash_.Add();
}
inline void InitRequest::add_package_hash(const std::string& value) {
  _impl_.package_hash_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:rsh.protocol.InitRequest.package_hash)
}
inline void InitRequest::add_package_hash(std::string&& value) {
  _impl_.package_hash_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:rsh.protocol.InitRequest.package_hash)
}
inline void InitRequest::add_package_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.package_hash_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:rsh.protocol.InitRequest.package_hash)
}
inline void InitRequest::add_package_hash(const void* value, size_t size) {
  _impl_.package_hash_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:rsh.protocol.InitRequest.package_hash)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InitRequest::package_hash() const {
  // @@protoc_insertion_point(field_list:rsh.protocol.InitRequest.package_hash)
  return _impl_.package_hash_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InitRequest::mutable_package_hash() {
  // @@protoc_insertion_point(field_mutable_list:rsh.protocol.InitRequest.package_hash)
  return &_impl_.package_hash_;
}

// -------------------------------------------------------------------

// InitResponse

// -------------------------------------------------------------------

// CompileRequest

// .rsh.protocol.Function function = 2;
inline bool CompileRequest::_internal_has_function() const {
  return this != internal_default_instance() && _impl_.function_ != nullptr;
}
inline bool CompileRequest::has_function() const {
  return _internal_has_function();
}
inline void CompileRequest::clear_function() {
  if (GetArenaForAllocation() == nullptr && _impl_.function_ != nullptr) {
    delete _impl_.function_;
  }
  _impl_.function_ = nullptr;
}
inline const ::rsh::protocol::Function& CompileRequest::_internal_function() const {
  const ::rsh::protocol::Function* p = _impl_.function_;
  return p != nullptr ? *p : reinterpret_cast<const ::rsh::protocol::Function&>(
      ::rsh::protocol::_Function_default_instance_);
}
inline const ::rsh::protocol::Function& CompileRequest::function() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.CompileRequest.function)
  return _internal_function();
}
inline void CompileRequest::unsafe_arena_set_allocated_function(
    ::rsh::protocol::Function* function) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.function_);
  }
  _impl_.function_ = function;
  if (function) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rsh.protocol.CompileRequest.function)
}
inline ::rsh::protocol::Function* CompileRequest::release_function() {
  
  ::rsh::protocol::Function* temp = _impl_.function_;
  _impl_.function_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rsh::protocol::Function* CompileRequest::unsafe_arena_release_function() {
  // @@protoc_insertion_point(field_release:rsh.protocol.CompileRequest.function)
  
  ::rsh::protocol::Function* temp = _impl_.function_;
  _impl_.function_ = nullptr;
  return temp;
}
inline ::rsh::protocol::Function* CompileRequest::_internal_mutable_function() {
  
  if (_impl_.function_ == nullptr) {
    auto* p = CreateMaybeMessage<::rsh::protocol::Function>(GetArenaForAllocation());
    _impl_.function_ = p;
  }
  return _impl_.function_;
}
inline ::rsh::protocol::Function* CompileRequest::mutable_function() {
  ::rsh::protocol::Function* _msg = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.CompileRequest.function)
  return _msg;
}
inline void CompileRequest::set_allocated_function(::rsh::protocol::Function* function) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.function_;
  }
  if (function) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(function);
    if (message_arena != submessage_arena) {
      function = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, function, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.function_ = function;
  // @@protoc_insertion_point(field_set_allocated:rsh.protocol.CompileRequest.function)
}

// optional .rsh.protocol.Tier tier = 4;
inline bool CompileRequest::_internal_has_tier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CompileRequest::has_tier() const {
  return _internal_has_tier();
}
inline void CompileRequest::clear_tier() {
  _impl_.tier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::rsh::protocol::Tier CompileRequest::_internal_tier() const {
  return static_cast< ::rsh::protocol::Tier >(_impl_.tier_);
}
inline ::rsh::protocol::Tier CompileRequest::tier() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.CompileRequest.tier)
  return _internal_tier();
}
inline void CompileRequest::_internal_set_tier(::rsh::protocol::Tier value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.tier_ = value;
}
inline void CompileRequest::set_tier(::rsh::protocol::Tier value) {
  _internal_set_tier(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.CompileRequest.tier)
}

// optional int32 cc_opt = 5;
inline bool CompileRequest::_internal_has_cc_opt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CompileRequest::has_cc_opt() const {
  return _internal_has_cc_opt();
}
inline void CompileRequest::clear_cc_opt() {
  _impl_.cc_opt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t CompileRequest::_internal_cc_opt() const {
  return _impl_.cc_opt_;
}
inline int32_t CompileRequest::cc_opt() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.CompileRequest.cc_opt)
  return _internal_cc_opt();
}
inline void CompileRequest::_internal_set_cc_opt(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.cc_opt_ = value;
}
inline void CompileRequest::set_cc_opt(int32_t value) {
  _internal_set_cc_opt(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.CompileRequest.cc_opt)
}

// optional int32 bc_opt = 6;
inline bool CompileRequest::_internal_has_bc_opt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CompileRequest::has_bc_opt() const {
  return _internal_has_bc_opt();
}
inline void CompileRequest::clear_bc_opt() {
  _impl_.bc_opt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t CompileRequest::_internal_bc_opt() const {
  return _impl_.bc_opt_;
}
inline int32_t CompileRequest::bc_opt() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.CompileRequest.bc_opt)
  return _internal_bc_opt();
}
inline void CompileRequest::_internal_set_bc_opt(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.bc_opt_ = value;
}
inline void CompileRequest::set_bc_opt(int32_t value) {
  _internal_set_bc_opt(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.CompileRequest.bc_opt)
}

// optional .rsh.protocol.Context context = 7;
inline bool CompileRequest::_internal_has_context() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.context_ != nullptr);
  return value;
}
inline bool CompileRequest::has_context() const {
  return _internal_has_context();
}
inline void CompileRequest::clear_context() {
  if (_impl_.context_ != nullptr) _impl_.context_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rsh::protocol::Context& CompileRequest::_internal_context() const {
  const ::rsh::protocol::Context* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::rsh::protocol::Context&>(
      ::rsh::protocol::_Context_default_instance_);
}
inline const ::rsh::protocol::Context& CompileRequest::context() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.CompileRequest.context)
  return _internal_context();
}
inline void CompileRequest::unsafe_arena_set_allocated_context(
    ::rsh::protocol::Context* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rsh.protocol.CompileRequest.context)
}
inline ::rsh::protocol::Context* CompileRequest::release_context() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rsh::protocol::Context* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rsh::protocol::Context* CompileRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:rsh.protocol.CompileRequest.context)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rsh::protocol::Context* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::rsh::protocol::Context* CompileRequest::_internal_mutable_context() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::rsh::protocol::Context>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::rsh::protocol::Context* CompileRequest::mutable_context() {
  ::rsh::protocol::Context* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.CompileRequest.context)
  return _msg;
}
inline void CompileRequest::set_allocated_context(::rsh::protocol::Context* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:rsh.protocol.CompileRequest.context)
}

// optional .rsh.protocol.Environment environment = 8;
inline bool CompileRequest::_internal_has_environment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.environment_ != nullptr);
  return value;
}
inline bool CompileRequest::has_environment() const {
  return _internal_has_environment();
}
inline void CompileRequest::clear_environment() {
  if (_impl_.environment_ != nullptr) _impl_.environment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::rsh::protocol::Environment& CompileRequest::_internal_environment() const {
  const ::rsh::protocol::Environment* p = _impl_.environment_;
  return p != nullptr ? *p : reinterpret_cast<const ::rsh::protocol::Environment&>(
      ::rsh::protocol::_Environment_default_instance_);
}
inline const ::rsh::protocol::Environment& CompileRequest::environment() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.CompileRequest.environment)
  return _internal_environment();
}
inline void CompileRequest::unsafe_arena_set_allocated_environment(
    ::rsh::protocol::Environment* environment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.environment_);
  }
  _impl_.environment_ = environment;
  if (environment) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rsh.protocol.CompileRequest.environment)
}
inline ::rsh::protocol::Environment* CompileRequest::release_environment() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rsh::protocol::Environment* temp = _impl_.environment_;
  _impl_.environment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rsh::protocol::Environment* CompileRequest::unsafe_arena_release_environment() {
  // @@protoc_insertion_point(field_release:rsh.protocol.CompileRequest.environment)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rsh::protocol::Environment* temp = _impl_.environment_;
  _impl_.environment_ = nullptr;
  return temp;
}
inline ::rsh::protocol::Environment* CompileRequest::_internal_mutable_environment() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.environment_ == nullptr) {
    auto* p = CreateMaybeMessage<::rsh::protocol::Environment>(GetArenaForAllocation());
    _impl_.environment_ = p;
  }
  return _impl_.environment_;
}
inline ::rsh::protocol::Environment* CompileRequest::mutable_environment() {
  ::rsh::protocol::Environment* _msg = _internal_mutable_environment();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.CompileRequest.environment)
  return _msg;
}
inline void CompileRequest::set_allocated_environment(::rsh::protocol::Environment* environment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.environment_;
  }
  if (environment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(environment);
    if (message_arena != submessage_arena) {
      environment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, environment, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.environment_ = environment;
  // @@protoc_insertion_point(field_set_allocated:rsh.protocol.CompileRequest.environment)
}

// -------------------------------------------------------------------

// CompileResponse

// uint64 hash = 1;
inline void CompileResponse::clear_hash() {
  _impl_.hash_ = uint64_t{0u};
}
inline uint64_t CompileResponse::_internal_hash() const {
  return _impl_.hash_;
}
inline uint64_t CompileResponse::hash() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.CompileResponse.hash)
  return _internal_hash();
}
inline void CompileResponse::_internal_set_hash(uint64_t value) {
  
  _impl_.hash_ = value;
}
inline void CompileResponse::set_hash(uint64_t value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.CompileResponse.hash)
}

// .rsh.protocol.Tier tier = 2;
inline void CompileResponse::clear_tier() {
  _impl_.tier_ = 0;
}
inline ::rsh::protocol::Tier CompileResponse::_internal_tier() const {
  return static_cast< ::rsh::protocol::Tier >(_impl_.tier_);
}
inline ::rsh::protocol::Tier CompileResponse::tier() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.CompileResponse.tier)
  return _internal_tier();
}
inline void CompileResponse::_internal_set_tier(::rsh::protocol::Tier value) {
  
  _impl_.tier_ = value;
}
inline void CompileResponse::set_tier(::rsh::protocol::Tier value) {
  _internal_set_tier(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.CompileResponse.tier)
}

// optional bytes code = 3;
inline bool CompileResponse::_internal_has_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CompileResponse::has_code() const {
  return _internal_has_code();
}
inline void CompileResponse::clear_code() {
  _impl_.code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CompileResponse::code() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.CompileResponse.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompileResponse::set_code(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.code_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rsh.protocol.CompileResponse.code)
}
inline std::string* CompileResponse::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.CompileResponse.code)
  return _s;
}
inline const std::string& CompileResponse::_internal_code() const {
  return _impl_.code_.Get();
}
inline void CompileResponse::_internal_set_code(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* CompileResponse::_internal_mutable_code() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* CompileResponse::release_code() {
  // @@protoc_insertion_point(field_release:rsh.protocol.CompileResponse.code)
  if (!_internal_has_code()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CompileResponse::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rsh.protocol.CompileResponse.code)
}

// optional bytes constants = 4;
inline bool CompileResponse::_internal_has_constants() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CompileResponse::has_constants() const {
  return _internal_has_constants();
}
inline void CompileResponse::clear_constants() {
  _impl_.constants_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CompileResponse::constants() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.CompileResponse.constants)
  return _internal_constants();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompileResponse::set_constants(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.constants_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rsh.protocol.CompileResponse.constants)
}
inline std::string* CompileResponse::mutable_constants() {
  std::string* _s = _internal_mutable_constants();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.CompileResponse.constants)
  return _s;
}
inline const std::string& CompileResponse::_internal_constants() const {
  return _impl_.constants_.Get();
}
inline void CompileResponse::_internal_set_constants(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.constants_.Set(value, GetArenaForAllocation());
}
inline std::string* CompileResponse::_internal_mutable_constants() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.constants_.Mutable(GetArenaForAllocation());
}
inline std::string* CompileResponse::release_constants() {
  // @@protoc_insertion_point(field_release:rsh.protocol.CompileResponse.constants)
  if (!_internal_has_constants()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.constants_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.constants_.IsDefault()) {
    _impl_.constants_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CompileResponse::set_allocated_constants(std::string* constants) {
  if (constants != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.constants_.SetAllocated(constants, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.constants_.IsDefault()) {
    _impl_.constants_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rsh.protocol.CompileResponse.constants)
}

// -------------------------------------------------------------------

// Function

// uint64 package_hash = 1;
inline void Function::clear_package_hash() {
  _impl_.package_hash_ = uint64_t{0u};
}
inline uint64_t Function::_internal_package_hash() const {
  return _impl_.package_hash_;
}
inline uint64_t Function::package_hash() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.Function.package_hash)
  return _internal_package_hash();
}
inline void Function::_internal_set_package_hash(uint64_t value) {
  
  _impl_.package_hash_ = value;
}
inline void Function::set_package_hash(uint64_t value) {
  _internal_set_package_hash(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.Function.package_hash)
}

// string name = 2;
inline void Function::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Function::name() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.Function.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Function::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rsh.protocol.Function.name)
}
inline std::string* Function::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.Function.name)
  return _s;
}
inline const std::string& Function::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Function::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Function::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Function::release_name() {
  // @@protoc_insertion_point(field_release:rsh.protocol.Function.name)
  return _impl_.name_.Release();
}
inline void Function::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rsh.protocol.Function.name)
}

// uint64 hash = 3;
inline void Function::clear_hash() {
  _impl_.hash_ = uint64_t{0u};
}
inline uint64_t Function::_internal_hash() const {
  return _impl_.hash_;
}
inline uint64_t Function::hash() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.Function.hash)
  return _internal_hash();
}
inline void Function::_internal_set_hash(uint64_t value) {
  
  _impl_.hash_ = value;
}
inline void Function::set_hash(uint64_t value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.Function.hash)
}

// optional bytes body = 4;
inline bool Function::_internal_has_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Function::has_body() const {
  return _internal_has_body();
}
inline void Function::clear_body() {
  _impl_.body_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Function::body() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.Function.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Function::set_body(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.body_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rsh.protocol.Function.body)
}
inline std::string* Function::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.Function.body)
  return _s;
}
inline const std::string& Function::_internal_body() const {
  return _impl_.body_.Get();
}
inline void Function::_internal_set_body(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.body_.Set(value, GetArenaForAllocation());
}
inline std::string* Function::_internal_mutable_body() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.body_.Mutable(GetArenaForAllocation());
}
inline std::string* Function::release_body() {
  // @@protoc_insertion_point(field_release:rsh.protocol.Function.body)
  if (!_internal_has_body()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.body_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Function::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.body_.SetAllocated(body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rsh.protocol.Function.body)
}

// -------------------------------------------------------------------

// FunctionRequest

// uint64 hash = 1;
inline void FunctionRequest::clear_hash() {
  _impl_.hash_ = uint64_t{0u};
}
inline uint64_t FunctionRequest::_internal_hash() const {
  return _impl_.hash_;
}
inline uint64_t FunctionRequest::hash() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.FunctionRequest.hash)
  return _internal_hash();
}
inline void FunctionRequest::_internal_set_hash(uint64_t value) {
  
  _impl_.hash_ = value;
}
inline void FunctionRequest::set_hash(uint64_t value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.FunctionRequest.hash)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Environment

// map<string, uint64> values = 1;
inline int Environment::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Environment::values_size() const {
  return _internal_values_size();
}
inline void Environment::clear_values() {
  _impl_.values_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >&
Environment::_internal_values() const {
  return _impl_.values_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >&
Environment::values() const {
  // @@protoc_insertion_point(field_map:rsh.protocol.Environment.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >*
Environment::_internal_mutable_values() {
  return _impl_.values_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >*
Environment::mutable_values() {
  // @@protoc_insertion_point(field_mutable_map:rsh.protocol.Environment.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// ValueRequest

// repeated uint64 hash = 1;
inline int ValueRequest::_internal_hash_size() const {
  return _impl_.hash_.size();
}
inline int ValueRequest::hash_size() const {
  return _internal_hash_size();
}
inline void ValueRequest::clear_hash() {
  _impl_.hash_.Clear();
}
inline uint64_t ValueRequest::_internal_hash(int index) const {
  return _impl_.hash_.Get(index);
}
inline uint64_t ValueRequest::hash(int index) const {
  // @@protoc_insertion_point(field_get:rsh.protocol.ValueRequest.hash)
  return _internal_hash(index);
}
inline void ValueRequest::set_hash(int index, uint64_t value) {
  _impl_.hash_.Set(index, value);
  // @@protoc_insertion_point(field_set:rsh.protocol.ValueRequest.hash)
}
inline void ValueRequest::_internal_add_hash(uint64_t value) {
  _impl_.hash_.Add(value);
}
inline void ValueRequest::add_hash(uint64_t value) {
  _internal_add_hash(value);
  // @@protoc_insertion_point(field_add:rsh.protocol.ValueRequest.hash)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
ValueRequest::_internal_hash() const {
  return _impl_.hash_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
ValueRequest::hash() const {
  // @@protoc_insertion_point(field_list:rsh.protocol.ValueRequest.hash)
  return _internal_hash();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
ValueRequest::_internal_mutable_hash() {
  return &_impl_.hash_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
ValueRequest::mutable_hash() {
  // @@protoc_insertion_point(field_mutable_list:rsh.protocol.ValueRequest.hash)
  return _internal_mutable_hash();
}

// -------------------------------------------------------------------

// Value

// uint64 hash = 1;
inline void Value::clear_hash() {
  _impl_.hash_ = uint64_t{0u};
}
inline uint64_t Value::_internal_hash() const {
  return _impl_.hash_;
}
inline uint64_t Value::hash() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.Value.hash)
  return _internal_hash();
}
inline void Value::_internal_set_hash(uint64_t value) {
  
  _impl_.hash_ = value;
}
inline void Value::set_hash(uint64_t value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.Value.hash)
}

// bytes value = 2;
inline void Value::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Value::value() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.Value.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Value::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rsh.protocol.Value.value)
}
inline std::string* Value::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.Value.value)
  return _s;
}
inline const std::string& Value::_internal_value() const {
  return _impl_.value_.Get();
}
inline void Value::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Value::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Value::release_value() {
  // @@protoc_insertion_point(field_release:rsh.protocol.Value.value)
  return _impl_.value_.Release();
}
inline void Value::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rsh.protocol.Value.value)
}

// -------------------------------------------------------------------

// Values

// repeated .rsh.protocol.Value values = 1;
inline int Values::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Values::values_size() const {
  return _internal_values_size();
}
inline void Values::clear_values() {
  _impl_.values_.Clear();
}
inline ::rsh::protocol::Value* Values::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:rsh.protocol.Values.values)
  return _impl_.values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rsh::protocol::Value >*
Values::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:rsh.protocol.Values.values)
  return &_impl_.values_;
}
inline const ::rsh::protocol::Value& Values::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline const ::rsh::protocol::Value& Values::values(int index) const {
  // @@protoc_insertion_point(field_get:rsh.protocol.Values.values)
  return _internal_values(index);
}
inline ::rsh::protocol::Value* Values::_internal_add_values() {
  return _impl_.values_.Add();
}
inline ::rsh::protocol::Value* Values::add_values() {
  ::rsh::protocol::Value* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:rsh.protocol.Values.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rsh::protocol::Value >&
Values::values() const {
  // @@protoc_insertion_point(field_list:rsh.protocol.Values.values)
  return _impl_.values_;
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// CallContext

// bool args_statically_matched = 1;
inline void CallContext::clear_args_statically_matched() {
  _impl_.args_statically_matched_ = false;
}
inline bool CallContext::_internal_args_statically_matched() const {
  return _impl_.args_statically_matched_;
}
inline bool CallContext::args_statically_matched() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.CallContext.args_statically_matched)
  return _internal_args_statically_matched();
}
inline void CallContext::_internal_set_args_statically_matched(bool value) {
  
  _impl_.args_statically_matched_ = value;
}
inline void CallContext::set_args_statically_matched(bool value) {
  _internal_set_args_statically_matched(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.CallContext.args_statically_matched)
}

// bool correct_number_of_args = 2;
inline void CallContext::clear_correct_number_of_args() {
  _impl_.correct_number_of_args_ = false;
}
inline bool CallContext::_internal_correct_number_of_args() const {
  return _impl_.correct_number_of_args_;
}
inline bool CallContext::correct_number_of_args() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.CallContext.correct_number_of_args)
  return _internal_correct_number_of_args();
}
inline void CallContext::_internal_set_correct_number_of_args(bool value) {
  
  _impl_.correct_number_of_args_ = value;
}
inline void CallContext::set_correct_number_of_args(bool value) {
  _internal_set_correct_number_of_args(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.CallContext.correct_number_of_args)
}

// bool correct_order_of_args = 3;
inline void CallContext::clear_correct_order_of_args() {
  _impl_.correct_order_of_args_ = false;
}
inline bool CallContext::_internal_correct_order_of_args() const {
  return _impl_.correct_order_of_args_;
}
inline bool CallContext::correct_order_of_args() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.CallContext.correct_order_of_args)
  return _internal_correct_order_of_args();
}
inline void CallContext::_internal_set_correct_order_of_args(bool value) {
  
  _impl_.correct_order_of_args_ = value;
}
inline void CallContext::set_correct_order_of_args(bool value) {
  _internal_set_correct_order_of_args(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.CallContext.correct_order_of_args)
}

// bool no_missing_args = 4;
inline void CallContext::clear_no_missing_args() {
  _impl_.no_missing_args_ = false;
}
inline bool CallContext::_internal_no_missing_args() const {
  return _impl_.no_missing_args_;
}
inline bool CallContext::no_missing_args() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.CallContext.no_missing_args)
  return _internal_no_missing_args();
}
inline void CallContext::_internal_set_no_missing_args(bool value) {
  
  _impl_.no_missing_args_ = value;
}
inline void CallContext::set_no_missing_args(bool value) {
  _internal_set_no_missing_args(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.CallContext.no_missing_args)
}

// -------------------------------------------------------------------

// ArgumentContext

// bool eager = 1;
inline void ArgumentContext::clear_eager() {
  _impl_.eager_ = false;
}
inline bool ArgumentContext::_internal_eager() const {
  return _impl_.eager_;
}
inline bool ArgumentContext::eager() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.ArgumentContext.eager)
  return _internal_eager();
}
inline void ArgumentContext::_internal_set_eager(bool value) {
  
  _impl_.eager_ = value;
}
inline void ArgumentContext::set_eager(bool value) {
  _internal_set_eager(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.ArgumentContext.eager)
}

// bool reflection = 2;
inline void ArgumentContext::clear_reflection() {
  _impl_.reflection_ = false;
}
inline bool ArgumentContext::_internal_reflection() const {
  return _impl_.reflection_;
}
inline bool ArgumentContext::reflection() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.ArgumentContext.reflection)
  return _internal_reflection();
}
inline void ArgumentContext::_internal_set_reflection(bool value) {
  
  _impl_.reflection_ = value;
}
inline void ArgumentContext::set_reflection(bool value) {
  _internal_set_reflection(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.ArgumentContext.reflection)
}

// bool object = 3;
inline void ArgumentContext::clear_object() {
  _impl_.object_ = false;
}
inline bool ArgumentContext::_internal_object() const {
  return _impl_.object_;
}
inline bool ArgumentContext::object() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.ArgumentContext.object)
  return _internal_object();
}
inline void ArgumentContext::_internal_set_object(bool value) {
  
  _impl_.object_ = value;
}
inline void ArgumentContext::set_object(bool value) {
  _internal_set_object(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.ArgumentContext.object)
}

// optional .rsh.protocol.Type type = 4;
inline bool ArgumentContext::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ArgumentContext::has_type() const {
  return _internal_has_type();
}
inline void ArgumentContext::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::rsh::protocol::Type ArgumentContext::_internal_type() const {
  return static_cast< ::rsh::protocol::Type >(_impl_.type_);
}
inline ::rsh::protocol::Type ArgumentContext::type() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.ArgumentContext.type)
  return _internal_type();
}
inline void ArgumentContext::_internal_set_type(::rsh::protocol::Type value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void ArgumentContext::set_type(::rsh::protocol::Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.ArgumentContext.type)
}

// -------------------------------------------------------------------

// Context

// .rsh.protocol.CallContext call_context = 1;
inline bool Context::_internal_has_call_context() const {
  return this != internal_default_instance() && _impl_.call_context_ != nullptr;
}
inline bool Context::has_call_context() const {
  return _internal_has_call_context();
}
inline void Context::clear_call_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.call_context_ != nullptr) {
    delete _impl_.call_context_;
  }
  _impl_.call_context_ = nullptr;
}
inline const ::rsh::protocol::CallContext& Context::_internal_call_context() const {
  const ::rsh::protocol::CallContext* p = _impl_.call_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::rsh::protocol::CallContext&>(
      ::rsh::protocol::_CallContext_default_instance_);
}
inline const ::rsh::protocol::CallContext& Context::call_context() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.Context.call_context)
  return _internal_call_context();
}
inline void Context::unsafe_arena_set_allocated_call_context(
    ::rsh::protocol::CallContext* call_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.call_context_);
  }
  _impl_.call_context_ = call_context;
  if (call_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rsh.protocol.Context.call_context)
}
inline ::rsh::protocol::CallContext* Context::release_call_context() {
  
  ::rsh::protocol::CallContext* temp = _impl_.call_context_;
  _impl_.call_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rsh::protocol::CallContext* Context::unsafe_arena_release_call_context() {
  // @@protoc_insertion_point(field_release:rsh.protocol.Context.call_context)
  
  ::rsh::protocol::CallContext* temp = _impl_.call_context_;
  _impl_.call_context_ = nullptr;
  return temp;
}
inline ::rsh::protocol::CallContext* Context::_internal_mutable_call_context() {
  
  if (_impl_.call_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::rsh::protocol::CallContext>(GetArenaForAllocation());
    _impl_.call_context_ = p;
  }
  return _impl_.call_context_;
}
inline ::rsh::protocol::CallContext* Context::mutable_call_context() {
  ::rsh::protocol::CallContext* _msg = _internal_mutable_call_context();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.Context.call_context)
  return _msg;
}
inline void Context::set_allocated_call_context(::rsh::protocol::CallContext* call_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.call_context_;
  }
  if (call_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(call_context);
    if (message_arena != submessage_arena) {
      call_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, call_context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.call_context_ = call_context;
  // @@protoc_insertion_point(field_set_allocated:rsh.protocol.Context.call_context)
}

// repeated .rsh.protocol.ArgumentContext argument_context = 2;
inline int Context::_internal_argument_context_size() const {
  return _impl_.argument_context_.size();
}
inline int Context::argument_context_size() const {
  return _internal_argument_context_size();
}
inline void Context::clear_argument_context() {
  _impl_.argument_context_.Clear();
}
inline ::rsh::protocol::ArgumentContext* Context::mutable_argument_context(int index) {
  // @@protoc_insertion_point(field_mutable:rsh.protocol.Context.argument_context)
  return _impl_.argument_context_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rsh::protocol::ArgumentContext >*
Context::mutable_argument_context() {
  // @@protoc_insertion_point(field_mutable_list:rsh.protocol.Context.argument_context)
  return &_impl_.argument_context_;
}
inline const ::rsh::protocol::ArgumentContext& Context::_internal_argument_context(int index) const {
  return _impl_.argument_context_.Get(index);
}
inline const ::rsh::protocol::ArgumentContext& Context::argument_context(int index) const {
  // @@protoc_insertion_point(field_get:rsh.protocol.Context.argument_context)
  return _internal_argument_context(index);
}
inline ::rsh::protocol::ArgumentContext* Context::_internal_add_argument_context() {
  return _impl_.argument_context_.Add();
}
inline ::rsh::protocol::ArgumentContext* Context::add_argument_context() {
  ::rsh::protocol::ArgumentContext* _add = _internal_add_argument_context();
  // @@protoc_insertion_point(field_add:rsh.protocol.Context.argument_context)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rsh::protocol::ArgumentContext >&
Context::argument_context() const {
  // @@protoc_insertion_point(field_list:rsh.protocol.Context.argument_context)
  return _impl_.argument_context_;
}

// -------------------------------------------------------------------

// ContextRequest

// .rsh.protocol.Function function = 1;
inline bool ContextRequest::_internal_has_function() const {
  return this != internal_default_instance() && _impl_.function_ != nullptr;
}
inline bool ContextRequest::has_function() const {
  return _internal_has_function();
}
inline void ContextRequest::clear_function() {
  if (GetArenaForAllocation() == nullptr && _impl_.function_ != nullptr) {
    delete _impl_.function_;
  }
  _impl_.function_ = nullptr;
}
inline const ::rsh::protocol::Function& ContextRequest::_internal_function() const {
  const ::rsh::protocol::Function* p = _impl_.function_;
  return p != nullptr ? *p : reinterpret_cast<const ::rsh::protocol::Function&>(
      ::rsh::protocol::_Function_default_instance_);
}
inline const ::rsh::protocol::Function& ContextRequest::function() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.ContextRequest.function)
  return _internal_function();
}
inline void ContextRequest::unsafe_arena_set_allocated_function(
    ::rsh::protocol::Function* function) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.function_);
  }
  _impl_.function_ = function;
  if (function) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rsh.protocol.ContextRequest.function)
}
inline ::rsh::protocol::Function* ContextRequest::release_function() {
  
  ::rsh::protocol::Function* temp = _impl_.function_;
  _impl_.function_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rsh::protocol::Function* ContextRequest::unsafe_arena_release_function() {
  // @@protoc_insertion_point(field_release:rsh.protocol.ContextRequest.function)
  
  ::rsh::protocol::Function* temp = _impl_.function_;
  _impl_.function_ = nullptr;
  return temp;
}
inline ::rsh::protocol::Function* ContextRequest::_internal_mutable_function() {
  
  if (_impl_.function_ == nullptr) {
    auto* p = CreateMaybeMessage<::rsh::protocol::Function>(GetArenaForAllocation());
    _impl_.function_ = p;
  }
  return _impl_.function_;
}
inline ::rsh::protocol::Function* ContextRequest::mutable_function() {
  ::rsh::protocol::Function* _msg = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.ContextRequest.function)
  return _msg;
}
inline void ContextRequest::set_allocated_function(::rsh::protocol::Function* function) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.function_;
  }
  if (function) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(function);
    if (message_arena != submessage_arena) {
      function = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, function, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.function_ = function;
  // @@protoc_insertion_point(field_set_allocated:rsh.protocol.ContextRequest.function)
}

// -------------------------------------------------------------------

// TestFeedback

// .rsh.protocol.TestLattice test_lattice = 1;
inline void TestFeedback::clear_test_lattice() {
  _impl_.test_lattice_ = 0;
}
inline ::rsh::protocol::TestLattice TestFeedback::_internal_test_lattice() const {
  return static_cast< ::rsh::protocol::TestLattice >(_impl_.test_lattice_);
}
inline ::rsh::protocol::TestLattice TestFeedback::test_lattice() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.TestFeedback.test_lattice)
  return _internal_test_lattice();
}
inline void TestFeedback::_internal_set_test_lattice(::rsh::protocol::TestLattice value) {
  
  _impl_.test_lattice_ = value;
}
inline void TestFeedback::set_test_lattice(::rsh::protocol::TestLattice value) {
  _internal_set_test_lattice(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.TestFeedback.test_lattice)
}

// -------------------------------------------------------------------

// CallFeedback

// int64 n_calls = 1;
inline void CallFeedback::clear_n_calls() {
  _impl_.n_calls_ = int64_t{0};
}
inline int64_t CallFeedback::_internal_n_calls() const {
  return _impl_.n_calls_;
}
inline int64_t CallFeedback::n_calls() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.CallFeedback.n_calls)
  return _internal_n_calls();
}
inline void CallFeedback::_internal_set_n_calls(int64_t value) {
  
  _impl_.n_calls_ = value;
}
inline void CallFeedback::set_n_calls(int64_t value) {
  _internal_set_n_calls(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.CallFeedback.n_calls)
}

// uint64 callee_hash = 2;
inline void CallFeedback::clear_callee_hash() {
  _impl_.callee_hash_ = uint64_t{0u};
}
inline uint64_t CallFeedback::_internal_callee_hash() const {
  return _impl_.callee_hash_;
}
inline uint64_t CallFeedback::callee_hash() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.CallFeedback.callee_hash)
  return _internal_callee_hash();
}
inline void CallFeedback::_internal_set_callee_hash(uint64_t value) {
  
  _impl_.callee_hash_ = value;
}
inline void CallFeedback::set_callee_hash(uint64_t value) {
  _internal_set_callee_hash(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.CallFeedback.callee_hash)
}

// -------------------------------------------------------------------

// ValueFeedback

// bool scalar = 1;
inline void ValueFeedback::clear_scalar() {
  _impl_.scalar_ = false;
}
inline bool ValueFeedback::_internal_scalar() const {
  return _impl_.scalar_;
}
inline bool ValueFeedback::scalar() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.ValueFeedback.scalar)
  return _internal_scalar();
}
inline void ValueFeedback::_internal_set_scalar(bool value) {
  
  _impl_.scalar_ = value;
}
inline void ValueFeedback::set_scalar(bool value) {
  _internal_set_scalar(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.ValueFeedback.scalar)
}

// bool object = 2;
inline void ValueFeedback::clear_object() {
  _impl_.object_ = false;
}
inline bool ValueFeedback::_internal_object() const {
  return _impl_.object_;
}
inline bool ValueFeedback::object() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.ValueFeedback.object)
  return _internal_object();
}
inline void ValueFeedback::_internal_set_object(bool value) {
  
  _impl_.object_ = value;
}
inline void ValueFeedback::set_object(bool value) {
  _internal_set_object(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.ValueFeedback.object)
}

// bool accessed_attributes = 3;
inline void ValueFeedback::clear_accessed_attributes() {
  _impl_.accessed_attributes_ = false;
}
inline bool ValueFeedback::_internal_accessed_attributes() const {
  return _impl_.accessed_attributes_;
}
inline bool ValueFeedback::accessed_attributes() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.ValueFeedback.accessed_attributes)
  return _internal_accessed_attributes();
}
inline void ValueFeedback::_internal_set_accessed_attributes(bool value) {
  
  _impl_.accessed_attributes_ = value;
}
inline void ValueFeedback::set_accessed_attributes(bool value) {
  _internal_set_accessed_attributes(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.ValueFeedback.accessed_attributes)
}

// bool vectorizable = 4;
inline void ValueFeedback::clear_vectorizable() {
  _impl_.vectorizable_ = false;
}
inline bool ValueFeedback::_internal_vectorizable() const {
  return _impl_.vectorizable_;
}
inline bool ValueFeedback::vectorizable() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.ValueFeedback.vectorizable)
  return _internal_vectorizable();
}
inline void ValueFeedback::_internal_set_vectorizable(bool value) {
  
  _impl_.vectorizable_ = value;
}
inline void ValueFeedback::set_vectorizable(bool value) {
  _internal_set_vectorizable(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.ValueFeedback.vectorizable)
}

// bool is_promise = 5;
inline void ValueFeedback::clear_is_promise() {
  _impl_.is_promise_ = false;
}
inline bool ValueFeedback::_internal_is_promise() const {
  return _impl_.is_promise_;
}
inline bool ValueFeedback::is_promise() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.ValueFeedback.is_promise)
  return _internal_is_promise();
}
inline void ValueFeedback::_internal_set_is_promise(bool value) {
  
  _impl_.is_promise_ = value;
}
inline void ValueFeedback::set_is_promise(bool value) {
  _internal_set_is_promise(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.ValueFeedback.is_promise)
}

// -------------------------------------------------------------------

// TypeFeedback_Feedback

// .rsh.protocol.TestFeedback test_feedback = 1;
inline bool TypeFeedback_Feedback::_internal_has_test_feedback() const {
  return feedback_case() == kTestFeedback;
}
inline bool TypeFeedback_Feedback::has_test_feedback() const {
  return _internal_has_test_feedback();
}
inline void TypeFeedback_Feedback::set_has_test_feedback() {
  _impl_._oneof_case_[0] = kTestFeedback;
}
inline void TypeFeedback_Feedback::clear_test_feedback() {
  if (_internal_has_test_feedback()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.feedback_.test_feedback_;
    }
    clear_has_feedback();
  }
}
inline ::rsh::protocol::TestFeedback* TypeFeedback_Feedback::release_test_feedback() {
  // @@protoc_insertion_point(field_release:rsh.protocol.TypeFeedback.Feedback.test_feedback)
  if (_internal_has_test_feedback()) {
    clear_has_feedback();
    ::rsh::protocol::TestFeedback* temp = _impl_.feedback_.test_feedback_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.feedback_.test_feedback_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rsh::protocol::TestFeedback& TypeFeedback_Feedback::_internal_test_feedback() const {
  return _internal_has_test_feedback()
      ? *_impl_.feedback_.test_feedback_
      : reinterpret_cast< ::rsh::protocol::TestFeedback&>(::rsh::protocol::_TestFeedback_default_instance_);
}
inline const ::rsh::protocol::TestFeedback& TypeFeedback_Feedback::test_feedback() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.TypeFeedback.Feedback.test_feedback)
  return _internal_test_feedback();
}
inline ::rsh::protocol::TestFeedback* TypeFeedback_Feedback::unsafe_arena_release_test_feedback() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rsh.protocol.TypeFeedback.Feedback.test_feedback)
  if (_internal_has_test_feedback()) {
    clear_has_feedback();
    ::rsh::protocol::TestFeedback* temp = _impl_.feedback_.test_feedback_;
    _impl_.feedback_.test_feedback_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TypeFeedback_Feedback::unsafe_arena_set_allocated_test_feedback(::rsh::protocol::TestFeedback* test_feedback) {
  clear_feedback();
  if (test_feedback) {
    set_has_test_feedback();
    _impl_.feedback_.test_feedback_ = test_feedback;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rsh.protocol.TypeFeedback.Feedback.test_feedback)
}
inline ::rsh::protocol::TestFeedback* TypeFeedback_Feedback::_internal_mutable_test_feedback() {
  if (!_internal_has_test_feedback()) {
    clear_feedback();
    set_has_test_feedback();
    _impl_.feedback_.test_feedback_ = CreateMaybeMessage< ::rsh::protocol::TestFeedback >(GetArenaForAllocation());
  }
  return _impl_.feedback_.test_feedback_;
}
inline ::rsh::protocol::TestFeedback* TypeFeedback_Feedback::mutable_test_feedback() {
  ::rsh::protocol::TestFeedback* _msg = _internal_mutable_test_feedback();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.TypeFeedback.Feedback.test_feedback)
  return _msg;
}

// .rsh.protocol.CallFeedback call_feedback = 2;
inline bool TypeFeedback_Feedback::_internal_has_call_feedback() const {
  return feedback_case() == kCallFeedback;
}
inline bool TypeFeedback_Feedback::has_call_feedback() const {
  return _internal_has_call_feedback();
}
inline void TypeFeedback_Feedback::set_has_call_feedback() {
  _impl_._oneof_case_[0] = kCallFeedback;
}
inline void TypeFeedback_Feedback::clear_call_feedback() {
  if (_internal_has_call_feedback()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.feedback_.call_feedback_;
    }
    clear_has_feedback();
  }
}
inline ::rsh::protocol::CallFeedback* TypeFeedback_Feedback::release_call_feedback() {
  // @@protoc_insertion_point(field_release:rsh.protocol.TypeFeedback.Feedback.call_feedback)
  if (_internal_has_call_feedback()) {
    clear_has_feedback();
    ::rsh::protocol::CallFeedback* temp = _impl_.feedback_.call_feedback_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.feedback_.call_feedback_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rsh::protocol::CallFeedback& TypeFeedback_Feedback::_internal_call_feedback() const {
  return _internal_has_call_feedback()
      ? *_impl_.feedback_.call_feedback_
      : reinterpret_cast< ::rsh::protocol::CallFeedback&>(::rsh::protocol::_CallFeedback_default_instance_);
}
inline const ::rsh::protocol::CallFeedback& TypeFeedback_Feedback::call_feedback() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.TypeFeedback.Feedback.call_feedback)
  return _internal_call_feedback();
}
inline ::rsh::protocol::CallFeedback* TypeFeedback_Feedback::unsafe_arena_release_call_feedback() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rsh.protocol.TypeFeedback.Feedback.call_feedback)
  if (_internal_has_call_feedback()) {
    clear_has_feedback();
    ::rsh::protocol::CallFeedback* temp = _impl_.feedback_.call_feedback_;
    _impl_.feedback_.call_feedback_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TypeFeedback_Feedback::unsafe_arena_set_allocated_call_feedback(::rsh::protocol::CallFeedback* call_feedback) {
  clear_feedback();
  if (call_feedback) {
    set_has_call_feedback();
    _impl_.feedback_.call_feedback_ = call_feedback;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rsh.protocol.TypeFeedback.Feedback.call_feedback)
}
inline ::rsh::protocol::CallFeedback* TypeFeedback_Feedback::_internal_mutable_call_feedback() {
  if (!_internal_has_call_feedback()) {
    clear_feedback();
    set_has_call_feedback();
    _impl_.feedback_.call_feedback_ = CreateMaybeMessage< ::rsh::protocol::CallFeedback >(GetArenaForAllocation());
  }
  return _impl_.feedback_.call_feedback_;
}
inline ::rsh::protocol::CallFeedback* TypeFeedback_Feedback::mutable_call_feedback() {
  ::rsh::protocol::CallFeedback* _msg = _internal_mutable_call_feedback();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.TypeFeedback.Feedback.call_feedback)
  return _msg;
}

// .rsh.protocol.ValueFeedback value_feedback = 3;
inline bool TypeFeedback_Feedback::_internal_has_value_feedback() const {
  return feedback_case() == kValueFeedback;
}
inline bool TypeFeedback_Feedback::has_value_feedback() const {
  return _internal_has_value_feedback();
}
inline void TypeFeedback_Feedback::set_has_value_feedback() {
  _impl_._oneof_case_[0] = kValueFeedback;
}
inline void TypeFeedback_Feedback::clear_value_feedback() {
  if (_internal_has_value_feedback()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.feedback_.value_feedback_;
    }
    clear_has_feedback();
  }
}
inline ::rsh::protocol::ValueFeedback* TypeFeedback_Feedback::release_value_feedback() {
  // @@protoc_insertion_point(field_release:rsh.protocol.TypeFeedback.Feedback.value_feedback)
  if (_internal_has_value_feedback()) {
    clear_has_feedback();
    ::rsh::protocol::ValueFeedback* temp = _impl_.feedback_.value_feedback_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.feedback_.value_feedback_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rsh::protocol::ValueFeedback& TypeFeedback_Feedback::_internal_value_feedback() const {
  return _internal_has_value_feedback()
      ? *_impl_.feedback_.value_feedback_
      : reinterpret_cast< ::rsh::protocol::ValueFeedback&>(::rsh::protocol::_ValueFeedback_default_instance_);
}
inline const ::rsh::protocol::ValueFeedback& TypeFeedback_Feedback::value_feedback() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.TypeFeedback.Feedback.value_feedback)
  return _internal_value_feedback();
}
inline ::rsh::protocol::ValueFeedback* TypeFeedback_Feedback::unsafe_arena_release_value_feedback() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rsh.protocol.TypeFeedback.Feedback.value_feedback)
  if (_internal_has_value_feedback()) {
    clear_has_feedback();
    ::rsh::protocol::ValueFeedback* temp = _impl_.feedback_.value_feedback_;
    _impl_.feedback_.value_feedback_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TypeFeedback_Feedback::unsafe_arena_set_allocated_value_feedback(::rsh::protocol::ValueFeedback* value_feedback) {
  clear_feedback();
  if (value_feedback) {
    set_has_value_feedback();
    _impl_.feedback_.value_feedback_ = value_feedback;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rsh.protocol.TypeFeedback.Feedback.value_feedback)
}
inline ::rsh::protocol::ValueFeedback* TypeFeedback_Feedback::_internal_mutable_value_feedback() {
  if (!_internal_has_value_feedback()) {
    clear_feedback();
    set_has_value_feedback();
    _impl_.feedback_.value_feedback_ = CreateMaybeMessage< ::rsh::protocol::ValueFeedback >(GetArenaForAllocation());
  }
  return _impl_.feedback_.value_feedback_;
}
inline ::rsh::protocol::ValueFeedback* TypeFeedback_Feedback::mutable_value_feedback() {
  ::rsh::protocol::ValueFeedback* _msg = _internal_mutable_value_feedback();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.TypeFeedback.Feedback.value_feedback)
  return _msg;
}

inline bool TypeFeedback_Feedback::has_feedback() const {
  return feedback_case() != FEEDBACK_NOT_SET;
}
inline void TypeFeedback_Feedback::clear_has_feedback() {
  _impl_._oneof_case_[0] = FEEDBACK_NOT_SET;
}
inline TypeFeedback_Feedback::FeedbackCase TypeFeedback_Feedback::feedback_case() const {
  return TypeFeedback_Feedback::FeedbackCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TypeFeedback

// map<int64, .rsh.protocol.TypeFeedback.Feedback> types = 2;
inline int TypeFeedback::_internal_types_size() const {
  return _impl_.types_.size();
}
inline int TypeFeedback::types_size() const {
  return _internal_types_size();
}
inline void TypeFeedback::clear_types() {
  _impl_.types_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::rsh::protocol::TypeFeedback_Feedback >&
TypeFeedback::_internal_types() const {
  return _impl_.types_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::rsh::protocol::TypeFeedback_Feedback >&
TypeFeedback::types() const {
  // @@protoc_insertion_point(field_map:rsh.protocol.TypeFeedback.types)
  return _internal_types();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::rsh::protocol::TypeFeedback_Feedback >*
TypeFeedback::_internal_mutable_types() {
  return _impl_.types_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::rsh::protocol::TypeFeedback_Feedback >*
TypeFeedback::mutable_types() {
  // @@protoc_insertion_point(field_mutable_map:rsh.protocol.TypeFeedback.types)
  return _internal_mutable_types();
}

// -------------------------------------------------------------------

// FeedbackRequest

// .rsh.protocol.Function function = 1;
inline bool FeedbackRequest::_internal_has_function() const {
  return this != internal_default_instance() && _impl_.function_ != nullptr;
}
inline bool FeedbackRequest::has_function() const {
  return _internal_has_function();
}
inline void FeedbackRequest::clear_function() {
  if (GetArenaForAllocation() == nullptr && _impl_.function_ != nullptr) {
    delete _impl_.function_;
  }
  _impl_.function_ = nullptr;
}
inline const ::rsh::protocol::Function& FeedbackRequest::_internal_function() const {
  const ::rsh::protocol::Function* p = _impl_.function_;
  return p != nullptr ? *p : reinterpret_cast<const ::rsh::protocol::Function&>(
      ::rsh::protocol::_Function_default_instance_);
}
inline const ::rsh::protocol::Function& FeedbackRequest::function() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.FeedbackRequest.function)
  return _internal_function();
}
inline void FeedbackRequest::unsafe_arena_set_allocated_function(
    ::rsh::protocol::Function* function) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.function_);
  }
  _impl_.function_ = function;
  if (function) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rsh.protocol.FeedbackRequest.function)
}
inline ::rsh::protocol::Function* FeedbackRequest::release_function() {
  
  ::rsh::protocol::Function* temp = _impl_.function_;
  _impl_.function_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rsh::protocol::Function* FeedbackRequest::unsafe_arena_release_function() {
  // @@protoc_insertion_point(field_release:rsh.protocol.FeedbackRequest.function)
  
  ::rsh::protocol::Function* temp = _impl_.function_;
  _impl_.function_ = nullptr;
  return temp;
}
inline ::rsh::protocol::Function* FeedbackRequest::_internal_mutable_function() {
  
  if (_impl_.function_ == nullptr) {
    auto* p = CreateMaybeMessage<::rsh::protocol::Function>(GetArenaForAllocation());
    _impl_.function_ = p;
  }
  return _impl_.function_;
}
inline ::rsh::protocol::Function* FeedbackRequest::mutable_function() {
  ::rsh::protocol::Function* _msg = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.FeedbackRequest.function)
  return _msg;
}
inline void FeedbackRequest::set_allocated_function(::rsh::protocol::Function* function) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.function_;
  }
  if (function) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(function);
    if (message_arena != submessage_arena) {
      function = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, function, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.function_ = function;
  // @@protoc_insertion_point(field_set_allocated:rsh.protocol.FeedbackRequest.function)
}

// -------------------------------------------------------------------

// PackageSource

// string r_mirror = 2;
inline bool PackageSource::_internal_has_r_mirror() const {
  return source_case() == kRMirror;
}
inline bool PackageSource::has_r_mirror() const {
  return _internal_has_r_mirror();
}
inline void PackageSource::set_has_r_mirror() {
  _impl_._oneof_case_[0] = kRMirror;
}
inline void PackageSource::clear_r_mirror() {
  if (_internal_has_r_mirror()) {
    _impl_.source_.r_mirror_.Destroy();
    clear_has_source();
  }
}
inline const std::string& PackageSource::r_mirror() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.PackageSource.r_mirror)
  return _internal_r_mirror();
}
template <typename ArgT0, typename... ArgT>
inline void PackageSource::set_r_mirror(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_r_mirror()) {
    clear_source();
    set_has_r_mirror();
    _impl_.source_.r_mirror_.InitDefault();
  }
  _impl_.source_.r_mirror_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rsh.protocol.PackageSource.r_mirror)
}
inline std::string* PackageSource::mutable_r_mirror() {
  std::string* _s = _internal_mutable_r_mirror();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.PackageSource.r_mirror)
  return _s;
}
inline const std::string& PackageSource::_internal_r_mirror() const {
  if (_internal_has_r_mirror()) {
    return _impl_.source_.r_mirror_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void PackageSource::_internal_set_r_mirror(const std::string& value) {
  if (!_internal_has_r_mirror()) {
    clear_source();
    set_has_r_mirror();
    _impl_.source_.r_mirror_.InitDefault();
  }
  _impl_.source_.r_mirror_.Set(value, GetArenaForAllocation());
}
inline std::string* PackageSource::_internal_mutable_r_mirror() {
  if (!_internal_has_r_mirror()) {
    clear_source();
    set_has_r_mirror();
    _impl_.source_.r_mirror_.InitDefault();
  }
  return _impl_.source_.r_mirror_.Mutable(      GetArenaForAllocation());
}
inline std::string* PackageSource::release_r_mirror() {
  // @@protoc_insertion_point(field_release:rsh.protocol.PackageSource.r_mirror)
  if (_internal_has_r_mirror()) {
    clear_has_source();
    return _impl_.source_.r_mirror_.Release();
  } else {
    return nullptr;
  }
}
inline void PackageSource::set_allocated_r_mirror(std::string* r_mirror) {
  if (has_source()) {
    clear_source();
  }
  if (r_mirror != nullptr) {
    set_has_r_mirror();
    _impl_.source_.r_mirror_.InitAllocated(r_mirror, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:rsh.protocol.PackageSource.r_mirror)
}

// string github_url = 3;
inline bool PackageSource::_internal_has_github_url() const {
  return source_case() == kGithubUrl;
}
inline bool PackageSource::has_github_url() const {
  return _internal_has_github_url();
}
inline void PackageSource::set_has_github_url() {
  _impl_._oneof_case_[0] = kGithubUrl;
}
inline void PackageSource::clear_github_url() {
  if (_internal_has_github_url()) {
    _impl_.source_.github_url_.Destroy();
    clear_has_source();
  }
}
inline const std::string& PackageSource::github_url() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.PackageSource.github_url)
  return _internal_github_url();
}
template <typename ArgT0, typename... ArgT>
inline void PackageSource::set_github_url(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_github_url()) {
    clear_source();
    set_has_github_url();
    _impl_.source_.github_url_.InitDefault();
  }
  _impl_.source_.github_url_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rsh.protocol.PackageSource.github_url)
}
inline std::string* PackageSource::mutable_github_url() {
  std::string* _s = _internal_mutable_github_url();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.PackageSource.github_url)
  return _s;
}
inline const std::string& PackageSource::_internal_github_url() const {
  if (_internal_has_github_url()) {
    return _impl_.source_.github_url_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void PackageSource::_internal_set_github_url(const std::string& value) {
  if (!_internal_has_github_url()) {
    clear_source();
    set_has_github_url();
    _impl_.source_.github_url_.InitDefault();
  }
  _impl_.source_.github_url_.Set(value, GetArenaForAllocation());
}
inline std::string* PackageSource::_internal_mutable_github_url() {
  if (!_internal_has_github_url()) {
    clear_source();
    set_has_github_url();
    _impl_.source_.github_url_.InitDefault();
  }
  return _impl_.source_.github_url_.Mutable(      GetArenaForAllocation());
}
inline std::string* PackageSource::release_github_url() {
  // @@protoc_insertion_point(field_release:rsh.protocol.PackageSource.github_url)
  if (_internal_has_github_url()) {
    clear_has_source();
    return _impl_.source_.github_url_.Release();
  } else {
    return nullptr;
  }
}
inline void PackageSource::set_allocated_github_url(std::string* github_url) {
  if (has_source()) {
    clear_source();
  }
  if (github_url != nullptr) {
    set_has_github_url();
    _impl_.source_.github_url_.InitAllocated(github_url, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:rsh.protocol.PackageSource.github_url)
}

inline bool PackageSource::has_source() const {
  return source_case() != SOURCE_NOT_SET;
}
inline void PackageSource::clear_has_source() {
  _impl_._oneof_case_[0] = SOURCE_NOT_SET;
}
inline PackageSource::SourceCase PackageSource::source_case() const {
  return PackageSource::SourceCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Package

// string name = 1;
inline void Package::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Package::name() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.Package.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Package::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rsh.protocol.Package.name)
}
inline std::string* Package::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.Package.name)
  return _s;
}
inline const std::string& Package::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Package::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Package::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Package::release_name() {
  // @@protoc_insertion_point(field_release:rsh.protocol.Package.name)
  return _impl_.name_.Release();
}
inline void Package::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rsh.protocol.Package.name)
}

// .rsh.protocol.Version version = 2;
inline bool Package::_internal_has_version() const {
  return this != internal_default_instance() && _impl_.version_ != nullptr;
}
inline bool Package::has_version() const {
  return _internal_has_version();
}
inline void Package::clear_version() {
  if (GetArenaForAllocation() == nullptr && _impl_.version_ != nullptr) {
    delete _impl_.version_;
  }
  _impl_.version_ = nullptr;
}
inline const ::rsh::protocol::Version& Package::_internal_version() const {
  const ::rsh::protocol::Version* p = _impl_.version_;
  return p != nullptr ? *p : reinterpret_cast<const ::rsh::protocol::Version&>(
      ::rsh::protocol::_Version_default_instance_);
}
inline const ::rsh::protocol::Version& Package::version() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.Package.version)
  return _internal_version();
}
inline void Package::unsafe_arena_set_allocated_version(
    ::rsh::protocol::Version* version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.version_);
  }
  _impl_.version_ = version;
  if (version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rsh.protocol.Package.version)
}
inline ::rsh::protocol::Version* Package::release_version() {
  
  ::rsh::protocol::Version* temp = _impl_.version_;
  _impl_.version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rsh::protocol::Version* Package::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:rsh.protocol.Package.version)
  
  ::rsh::protocol::Version* temp = _impl_.version_;
  _impl_.version_ = nullptr;
  return temp;
}
inline ::rsh::protocol::Version* Package::_internal_mutable_version() {
  
  if (_impl_.version_ == nullptr) {
    auto* p = CreateMaybeMessage<::rsh::protocol::Version>(GetArenaForAllocation());
    _impl_.version_ = p;
  }
  return _impl_.version_;
}
inline ::rsh::protocol::Version* Package::mutable_version() {
  ::rsh::protocol::Version* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.Package.version)
  return _msg;
}
inline void Package::set_allocated_version(::rsh::protocol::Version* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.version_;
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(version);
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.version_ = version;
  // @@protoc_insertion_point(field_set_allocated:rsh.protocol.Package.version)
}

// repeated uint64 function_hashes = 4;
inline int Package::_internal_function_hashes_size() const {
  return _impl_.function_hashes_.size();
}
inline int Package::function_hashes_size() const {
  return _internal_function_hashes_size();
}
inline void Package::clear_function_hashes() {
  _impl_.function_hashes_.Clear();
}
inline uint64_t Package::_internal_function_hashes(int index) const {
  return _impl_.function_hashes_.Get(index);
}
inline uint64_t Package::function_hashes(int index) const {
  // @@protoc_insertion_point(field_get:rsh.protocol.Package.function_hashes)
  return _internal_function_hashes(index);
}
inline void Package::set_function_hashes(int index, uint64_t value) {
  _impl_.function_hashes_.Set(index, value);
  // @@protoc_insertion_point(field_set:rsh.protocol.Package.function_hashes)
}
inline void Package::_internal_add_function_hashes(uint64_t value) {
  _impl_.function_hashes_.Add(value);
}
inline void Package::add_function_hashes(uint64_t value) {
  _internal_add_function_hashes(value);
  // @@protoc_insertion_point(field_add:rsh.protocol.Package.function_hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Package::_internal_function_hashes() const {
  return _impl_.function_hashes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Package::function_hashes() const {
  // @@protoc_insertion_point(field_list:rsh.protocol.Package.function_hashes)
  return _internal_function_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Package::_internal_mutable_function_hashes() {
  return &_impl_.function_hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Package::mutable_function_hashes() {
  // @@protoc_insertion_point(field_mutable_list:rsh.protocol.Package.function_hashes)
  return _internal_mutable_function_hashes();
}

// optional .rsh.protocol.PackageSource source = 5;
inline bool Package::_internal_has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_ != nullptr);
  return value;
}
inline bool Package::has_source() const {
  return _internal_has_source();
}
inline void Package::clear_source() {
  if (_impl_.source_ != nullptr) _impl_.source_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rsh::protocol::PackageSource& Package::_internal_source() const {
  const ::rsh::protocol::PackageSource* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::rsh::protocol::PackageSource&>(
      ::rsh::protocol::_PackageSource_default_instance_);
}
inline const ::rsh::protocol::PackageSource& Package::source() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.Package.source)
  return _internal_source();
}
inline void Package::unsafe_arena_set_allocated_source(
    ::rsh::protocol::PackageSource* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  if (source) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rsh.protocol.Package.source)
}
inline ::rsh::protocol::PackageSource* Package::release_source() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rsh::protocol::PackageSource* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rsh::protocol::PackageSource* Package::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:rsh.protocol.Package.source)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rsh::protocol::PackageSource* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::rsh::protocol::PackageSource* Package::_internal_mutable_source() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::rsh::protocol::PackageSource>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::rsh::protocol::PackageSource* Package::mutable_source() {
  ::rsh::protocol::PackageSource* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:rsh.protocol.Package.source)
  return _msg;
}
inline void Package::set_allocated_source(::rsh::protocol::PackageSource* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:rsh.protocol.Package.source)
}

// -------------------------------------------------------------------

// PackageRequest

// uint64 hash = 1;
inline void PackageRequest::clear_hash() {
  _impl_.hash_ = uint64_t{0u};
}
inline uint64_t PackageRequest::_internal_hash() const {
  return _impl_.hash_;
}
inline uint64_t PackageRequest::hash() const {
  // @@protoc_insertion_point(field_get:rsh.protocol.PackageRequest.hash)
  return _internal_hash();
}
inline void PackageRequest::_internal_set_hash(uint64_t value) {
  
  _impl_.hash_ = value;
}
inline void PackageRequest::set_hash(uint64_t value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:rsh.protocol.PackageRequest.hash)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace rsh

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::rsh::protocol::Tier> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rsh::protocol::Tier>() {
  return ::rsh::protocol::Tier_descriptor();
}
template <> struct is_proto_enum< ::rsh::protocol::TestLattice> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rsh::protocol::TestLattice>() {
  return ::rsh::protocol::TestLattice_descriptor();
}
template <> struct is_proto_enum< ::rsh::protocol::Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rsh::protocol::Type>() {
  return ::rsh::protocol::Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_messages_2eproto
