package org.prlprg.ir.type;

import com.google.common.collect.ImmutableList;
import java.util.Arrays;
import java.util.Collection;
import java.util.stream.Stream;
import org.prlprg.ir.CFG;
import org.prlprg.ir.type.lattice.MaybeNat;
import org.prlprg.ir.type.lattice.Troolean;
import org.prlprg.rshruntime.TypeFeedback;
import org.prlprg.sexp.*;
import org.prlprg.util.NotImplementedError;

/**
 * All global {@link RType}s and methods to create {@link RType}s are here so they're easy to find.
 */
public class RTypes {
  /** The type of an expression which hangs, errors, or otherwise diverts control flow. */
  public static final RType NOTHING = new RType();

  /**
   * The type of a value we know absolutely nothing about (this is common, e.g. arbitrary {@code
   * LdVar}).
   */
  public static final RType ANY =
      new RType(
          new RGenericValueType(
              null, BaseRType.ANY_VALUE, AttributesTypes.UNKNOWN, MaybeNat.UNKNOWN),
          RPromiseType.MAYBE_LAZY_PROMISE,
          Troolean.MAYBE);

  /** The type of a value we know absolutely nothing about, except that it's not a promise. */
  public static final RType ANY_VALUE =
      new RType(
          new RGenericValueType(
              null, BaseRType.ANY_VALUE, AttributesTypes.UNKNOWN, MaybeNat.UNKNOWN),
          RPromiseType.VALUE,
          Troolean.MAYBE);

  /**
   * The type of a value we know absolutely nothing about, except that it's not a promise or
   * missing.
   */
  public static final RType ANY_VALUE_NOT_MISSING =
      new RType(
          new RGenericValueType(
              null, BaseRType.ANY_VALUE, AttributesTypes.UNKNOWN, MaybeNat.UNKNOWN),
          RPromiseType.VALUE,
          Troolean.NO);

  /**
   * The type of a function we know absolutely nothing about besides it being a function (could be a
   * special or builtin).
   */
  public static final RType ANY_FUN =
      new RType(
          new RFunctionTypeImpl(
              null,
              null,
              AttributesTypes.UNKNOWN,
              MaybeNat.UNKNOWN,
              ImmutableList.of(),
              Troolean.MAYBE),
          RPromiseType.VALUE,
          Troolean.NO);

  /**
   * The type of a function we know absolutely nothing about besides it being a special or builtin
   * function.
   */
  public static final RType ANY_SYM_FUN = ANY_FUN;

  /**
   * The type of a value we know absolutely nothing about besides it not having attributes, object,
   * promise-wrapped, or missing (e.g. AST node).
   */
  public static final RType ANY_SIMPLE =
      new RType(
          new RGenericValueType(null, BaseRType.ANY_VALUE, AttributesTypes.NONE, MaybeNat.UNKNOWN),
          RPromiseType.VALUE,
          Troolean.NO);

  /** The {@link RType} of the missing value. */
  public static final RType OF_MISSING = new RType(null, RPromiseType.VALUE, Troolean.YES);

  /** The (most precise representable) type of the given value. */
  public static RType exact(SEXP value) {
    if (value instanceof PromSXP p) {
      return exact(p.val()).promiseWrapped(new RPromiseType.Promise(p));
    }
    if (value == SEXPs.MISSING_ARG) {
      return OF_MISSING;
    }
    return new RType(
        switch (value) {
          case CloSXP closure -> RFunctionTypeImpl.exact(closure);
          case PrimVectorSXP<?> primVec -> RPrimVecTypeImpl.exact(primVec);
          default -> RGenericValueType.exact(value);
        },
        RPromiseType.VALUE,
        Troolean.NO);
  }

  /** The type of a value which passes the assumptions generated by the feedback. */
  public static RType assume(TypeFeedback feedback) {
    throw new NotImplementedError();
  }

  /** The return type of this static call. TODO: Replace param call with {@code Closure} */
  public static RType staticCallReturn(CFG call) {
    throw new NotImplementedError();
  }

  /** The type after a arithmetic bytecode instruction. */
  public static RType arithmeticOp(RType... types) {
    throw new NotImplementedError();
  }

  /** The type after a comparison bytecode instruction. */
  public static RType comparisonOp(RType... types) {
    throw new NotImplementedError();
  }

  /** The type after a simple "and", "or", or "not" bytecode instruction. */
  public static RType booleanOp(RType... types) {
    throw new NotImplementedError();
  }

  /**
   * The type of a value we know has a specific {@link SEXPType} and no weirdness (no object or
   * attributes), produced by builtins. If {@code type} is the type of a primitive vector, this will
   * also return the type for a scalar.
   */
  public static RType simple(SEXPType type) {
    throw new NotImplementedError();
  }

  /** Type which is the union of all given types. */
  public static RType union(RType... types) {
    return union(Arrays.stream(types));
  }

  /** Type which is the union of all given types. */
  public static RType union(Collection<RType> types) {
    return union(types.stream());
  }

  /** Type which is the union of all given types. */
  public static RType union(Stream<RType> types) {
    return types.reduce(RType::union).orElse(NOTHING);
  }

  /** Type which is the intersection of all given types. */
  public static RType intersection(RType... types) {
    return intersection(Arrays.stream(types));
  }

  /** Type which is the intersection of all given types. */
  public static RType intersection(Collection<RType> types) {
    return intersection(types.stream());
  }

  /** Type which is the intersection of all given types. */
  public static RType intersection(Stream<RType> types) {
    return types.reduce(RType::intersection).orElse(ANY);
  }

  private RTypes() {}
}
