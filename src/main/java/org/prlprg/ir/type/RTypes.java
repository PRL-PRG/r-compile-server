package org.prlprg.ir.type;

import com.google.common.collect.ImmutableList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Objects;
import java.util.stream.Stream;
import org.prlprg.ir.cfg.CFG;
import org.prlprg.ir.type.BaseRType.NotPromise;
import org.prlprg.ir.type.lattice.Maybe;
import org.prlprg.ir.type.lattice.MaybeNat;
import org.prlprg.ir.type.lattice.NoOrMaybe;
import org.prlprg.primitive.BuiltinId;
import org.prlprg.rshruntime.TypeFeedback;
import org.prlprg.sexp.CloSXP;
import org.prlprg.sexp.PrimVectorSXP;
import org.prlprg.sexp.PromSXP;
import org.prlprg.sexp.SEXP;
import org.prlprg.sexp.SEXPType;
import org.prlprg.sexp.SEXPs;

/**
 * All global {@link RType}s and methods to create {@link RType}s are here so they're easy to find.
 */
public class RTypes {
  /** Create a function type with the given data, promise type, and missingness. */
  public static RType function(RFunctionType valueType, RPromiseType promiseType, Maybe missing) {
    return new RType(valueType, RPromiseType.of(promiseType), missing);
  }

  /** Create a primitive vector type with the given data, promise type, and missingness. */
  public static RType primVec(RPrimVecType valueType, RPromiseType promiseType, Maybe missing) {
    return new RType(valueType, RPromiseType.of(promiseType), missing);
  }

  /** The (most precise representable) type of the given value. */
  public static RType exact(SEXP value) {
    if (value instanceof PromSXP p) {
      return exact(p.val()).promiseWrapped(new RPromiseType.Promise(p));
    }
    if (value == SEXPs.MISSING_ARG) {
      return OF_MISSING;
    }
    return new RType(
        switch (value) {
          case CloSXP closure -> RFunctionTypeImpl.exact(closure);
          case PrimVectorSXP<?> primVec -> RPrimVecTypeImpl.exact(primVec);
          default -> RGenericValueType.exact(value);
        },
        RPromiseType.VALUE,
        Maybe.NO);
  }

  /** The type of a value which passes the assumptions generated by the feedback. */
  public static RType assume(TypeFeedback feedback) {
    // TODO
    return ANY;
  }

  /** The return type of this static call. TODO: Replace param call with {@code Closure} */
  public static RType staticCallReturn(CFG call) {
    // TODO
    return ANY;
  }

  /** The type after a arithmetic bytecode instruction, whose arguments have the given types. */
  public static RType arithmeticOp(RType... types) {
    // TODO
    return ANY;
  }

  /** The type after a comparison bytecode instruction, whose arguments have the given types. */
  public static RType comparisonOp(RType... types) {
    // TODO
    return ANY;
  }

  /**
   * The type after a simple "and", "or", or "not" bytecode instruction, whose arguments have the
   * given types.
   */
  public static RType booleanOp(RType... types) {
    // TODO
    return ANY;
  }

  /**
   * The type of a value we know has a specific {@link SEXPType} and no weirdness (no promise,
   * missing, or attributes), produced by builtins. If {@code type} is the type of a primitive
   * vector, this will also return the type for a scalar.
   *
   * @throws IllegalArgumentException if {@link SEXPType} is a promise, symbol, or "any".
   */
  public static RType simple(SEXPType type) {
    // TODO: make sure this is implemented correctly
    switch (type) {
      case SEXPType.PROM ->
          throw new IllegalArgumentException("No such thing as a \"simple promise\"");
      case SEXPType.ANY ->
          throw new IllegalArgumentException(
              "No such thing as a \"simple any\" (GNU-R's \"any\" type is special and has no instances)");
      case SEXPType.SYM ->
          throw new IllegalArgumentException("No such thing as a \"simple symbol\"");
    }
    var valueType =
        FunctionRType.of(type) != null
            ? new RFunctionTypeImpl(
                null,
                FunctionRType.of(type),
                AttributesTypes.NONE,
                MaybeNat.UNKNOWN,
                ImmutableList.of(),
                Maybe.MAYBE)
            : PrimVecElementRType.of(type) != null
                ? new RPrimVecTypeImpl(
                    null,
                    AttributesTypes.NONE,
                    MaybeNat.UNKNOWN,
                    Objects.requireNonNull(PrimVecElementRType.of(type)),
                    MaybeNat.UNKNOWN,
                    NoOrMaybe.NO)
                : new RGenericValueType(
                    null, (NotPromise) BaseRType.of(type), AttributesTypes.NONE, MaybeNat.UNKNOWN);
    return new RType(valueType, RPromiseType.VALUE, Maybe.NO);
  }

  public static RType toForSeq(RType ignored) {
    // TODO
    return ANY;
  }

  public static RType builtin(BuiltinId id) {
    // TODO: Specialize
    if (id.name().equals("environment")) {
      return simple(SEXPType.ENV);
    }
    return ANY_SYM_FUN;
  }

  /** Type which is the union of all given types. */
  public static RType union(RType... types) {
    return union(Arrays.stream(types));
  }

  /** Type which is the union of all given types. */
  public static RType union(Collection<RType> types) {
    return union(types.stream());
  }

  /** Type which is the union of all given types. */
  public static RType union(Stream<RType> types) {
    return types.reduce(RType::union).orElse(NOTHING);
  }

  /** Type which is the intersection of all given types. */
  public static RType intersection(RType... types) {
    return intersection(Arrays.stream(types));
  }

  /** Type which is the intersection of all given types. */
  public static RType intersection(Collection<RType> types) {
    return intersection(types.stream());
  }

  /** Type which is the intersection of all given types. */
  public static RType intersection(Stream<RType> types) {
    return types.reduce(RType::intersection).orElse(ANY);
  }

  private RTypes() {}
}
