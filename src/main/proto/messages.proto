syntax = "proto3";

option java_package = "org.prlprg.server";

// Error handling
// grpc already has a way to handle errors
// Status message: https://grpc.github.io/grpc-java/javadoc/io/grpc/Status.html

message Version {
  int32 major = 1;
  int32 minor = 2;
  int32 patch = 3;
}

message Package {
  string name = 1;
  Version version = 2;
  optional bytes hash = 3;
  repeated Function functions = 4;
}

message InitRequest {
  Version Rsh_version = 1;
  Version R_version = 2;
  string platform = 3;
  repeated Package packages = 4;
}

message InitResponse {}

message Function {
  optional string package = 1;// There can be only one version of a package loaded at a time
  string name = 2; //What if it is a closure passed to a HOF?
  optional bytes body = 3;
  optional bytes hash = 4;
}

enum TypeFeedback {
  SCALAR = 0;
  VECTOR = 1;// Add more types
}
enum Tier {
  BASELINE = 0;
  OPTIMIZED = 1;
}

message CompileRequest {
  Function function = 2;// Add package version
  optional Tier tier = 4;//if not defined, let the compile server decide
  optional int32 optimization_level = 5;// if not defined, the server decides
  repeated TypeFeedback type_feedback = 6;// n arguments + return type
  // should we rather use a map parameter -> type feedback?
  // Indeed if the types keep the same but parameters are swapped
  // in the parameter list, we should recompile the function
}

message CompileResponse {
  bytes hash = 1;
  Tier tier = 2;
  optional bytes native_code = 3;
  optional bytes constant_pool = 4;
}

message FactRequest {
  Function function = 1;
  string factName = 2;// Make it an enum when we know what kind of facts we would like to know about a function
}

message Fact {
  Function function = 1;// which function is that about
  string factName = 2;
  string factValue = 3;// Make it more typed when we know more about what kind of facts we want
}
