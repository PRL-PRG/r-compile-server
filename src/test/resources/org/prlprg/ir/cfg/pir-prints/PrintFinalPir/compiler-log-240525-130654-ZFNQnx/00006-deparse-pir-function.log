
┌──────────────────────────────────────────────────────────────────────────────┐
│ deparse[0x561ce6d759f0]                                                      │
│ Context: !ExpMi,CorrOrd,!TMany,Argmatch miss: 3                              │
│ Properties:  ForceOrd: 0                                                     │
├────── Final PIR Version
deparse[0x561ce6d759f0]
BB0
  val?^           %0.0  = LdArg                    1
  val?^           %0.1  = LdArg                    0
  env             e0.2  = MkEnv              l     expr=%0.1, width.cutoff=%0.0, backtick(miss)=missingArg, control(miss)=missingArg, nlines(miss)=missingArg, parent=R_BaseNamespace, context 1
  prom-           %0.3  = MkArg                    unboundValue, deparse[0x561ce6d759f0]_p0, e0.2
  val?^ | miss    %0.4  = CastType                 up %0.3
  void                    StArg              lW    backtick, %0.4, e0.2
  prom-           %0.6  = MkArg                    unboundValue, deparse[0x561ce6d759f0]_p4, e0.2
  val?^ | miss    %0.7  = CastType                 up %0.6
  void                    StArg              lW    control, %0.7, e0.2
  prom-           %0.9  = MkArg                    unboundValue, deparse[0x561ce6d759f0]_p5 (!refl), 
  val?^ | miss    %0.10 = CastType                 up %0.9
  void                    StArg              lW    nlines, %0.10, e0.2
  val?            %0.12 = Force!<lazy>       !v    %0.1, e0.2   <(sym|code)->
  lgl$#-          %0.13 = IsType                   %0.12 isA val?-
  void                    Branch                   %0.13 -> BB8 (if true) | BB9 (if false)
BB8   <- [0]
  val?-           %8.0  = CastType           d     dn %0.12   <(sym|code)->
  val?^ | miss    %8.1  = LdVar              eR    width.cutoff, e0.2
  val?            %8.2  = Force!<lazy>       !v    %8.1, e0.2   <int$->
  val?^ | miss    %8.3  = LdVar              eR    backtick, e0.2
  val?            %8.4  = Force!<lazy>       !v    %8.3, e0.2   <lgl$->
  val?^ | miss    %8.5  = LdVar              eR    .deparseOpts, e0.2
  lgl$#-          %8.6  = Identical                %8.5, function(control) <(rir::DispatchTable*)0x561c|...
  void                    Branch                   %8.6 -> BB10 (if true) | BB11 (if false)
BB9   <- [0]
  fs              %9.0  = FrameState         R     0x561ce5eb2cb0+9: [%0.12], env=e0.2
  void                    Deopt              !v    %9.0, Typecheck@0x561ce6c9af30[Type#5], %0.12   !
BB10   <- [8]
  val?^ | miss    %10.0 = LdVar              eR    control, e0.2
  val?            %10.1 = Force!<lazy>       !v    %10.0, e0.2   <str->
  prom-           %10.2 = MkArg                    %10.1, deparse[0x561ce6d759f0]_p6 (!refl), 
  val?            %10.3 = StaticCall         !v    .deparseOpts[0x561ce6d22920](%10.2) e0.2   <real$->
  lgl$#-          %10.4 = IsType                   %10.3 isA real$-
  void                    Branch                   %10.4 -> BB12 (if true) | BB13 (if false)
BB11   <- [8]
  fs              %11.0 = FrameState         R     0x561ce5eb2cb0+37: [%8.0, %8.2, %8.4], env=e0.2
  void                    Deopt              !v    %11.0, CallTarget@0x561ce6c9af30[Call#4], %8.5   !
BB12   <- [10]
  real$-          %12.0 = CastType           d     dn %10.3
  val?^ | miss    %12.1 = LdVar              eR    nlines, e0.2
  val?            %12.2 = Force!<lazy>       !v    %12.1, e0.2   <int$->
  val?            %12.3 = CallBuiltin        !     deparse(%8.0, %8.2, %8.4, %12.0, %12.2) e0.2
  void                    Return             l     %12.3
BB13   <- [10]
  fs              %13.0 = FrameState         R     0x561ce5eb2cb0+74: [%8.0, %8.2, %8.4, %10.3], env=e0.2
  void                    Deopt              !v    %13.0, Typecheck@0x561ce6c9af30[Type#9], %10.3   !
Prom 0:
BB0
  env             e0.0  = LdFunctionEnv            
  (cls|spec|blt)  %0.1  = LdFun              !     %in%, <0x561ce4eccc40>, e0.0
  prom-           %0.2  = MkArg                    unboundValue, deparse[0x561ce6d759f0]_p1, e0.0
  prom-           %0.3  = MkArg                    unboundValue, deparse[0x561ce6d759f0]_p3, e0.0
  val?            %0.4  = Call               !     %0.1(%0.2, %0.3) e0.0   <lgl$->
  void                    Return             l     %0.4
Prom 1:
BB0
  env             e0.0  = LdFunctionEnv            
  (cls|spec|blt)  %0.1  = LdFun              !     mode, <0x561ce5c9a140>, e0.0
  prom-           %0.2  = MkArg                    unboundValue, deparse[0x561ce6d759f0]_p2, e0.0
  val?            %0.3  = Call               !     %0.1(%0.2) e0.0   <str$->
  void                    Return             l     %0.3
Prom 2:
BB0
  env             e0.0  = LdFunctionEnv            
  val?^ | miss    %0.1  = LdVar              eR    expr, e0.0
  void                    Visible            v     
  val?            %0.3  = Force<wrapped>     !     %0.1, e0.0   <(sym|code)->
  void                    Return             l     %0.3
Prom 3:
BB0
  env             e0.0  = LdFunctionEnv            
  (cls|spec|blt)  %0.1  = LdFun              !     c, <0x561ce4bb6940>, e0.0
  val?            %0.2  = Call               !     %0.1("call", "expression", "(", "function") e0.0   <str->
  void                    Return             l     %0.2
Prom 4:
BB0
  env             e0.0  = LdFunctionEnv            
  (cls|spec|blt)  %0.1  = LdFun              !     c, <0x561ce4bb6940>, e0.0
  val?            %0.2  = Call               !     %0.1("keepNA", "keepInteger", "niceNames", "showAttributes") e0.0   <str->
  void                    Return             l     %0.2
Prom 5:
BB0
  void                    Visible            v     
  void                    Return             l     -1L
Prom 6:
BB0
  env             e0.0  = LdFunctionEnv            
  val?^ | miss    %0.1  = LdVar              eR    control, e0.0
  void                    Visible            v     
  val?            %0.3  = Force<lazy>        !     %0.1, e0.0   <str->
  void                    Return             l     %0.3

│ deparse[0x561ce6d759f0]                                                      │
└──────────────────────────────────────────────────────────────────────────────┘
