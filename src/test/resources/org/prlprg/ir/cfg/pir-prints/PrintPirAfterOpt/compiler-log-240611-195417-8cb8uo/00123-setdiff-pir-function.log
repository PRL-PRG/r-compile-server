
┌──────────────────────────────────────────────────────────────────────────────┐
│ setdiff[0x55b0cc156510]                                                      │
│ Context: !ExpMi,CorrOrd,!TMany,Argmatch                                      │
│ Properties:  ForceOrd: 0                                                     │
├────── PIR Version After Optimizations
setdiff[0x55b0cc156510]
BB0
  goto BB1
BB1   <- [0]
  val?^           %1.0  = LdArg                    1
  val?^           %1.1  = LdArg                    0
  env             e1.2  = MkEnv              l     x=%1.1, y=%1.0, parent=R_BaseNamespace, context 1
  val?            %1.3  = Force!<lazy>       !v    %1.1, e1.2   <str->
  lgl$#-          %1.4  = IsType                   %1.3 isA val?-
  cp              %1.5  = Checkpoint                -> BB2 (default) | BB18 (if assume failed)
BB2   <- [1]
  void                    Assume             D     %1.4, %1.5 (Typecheck@0x55b0cbcb7628[Type#0])
  val?-           %2.1  = CastType           d     dn %1.3   <str->
  val             %2.2  = CallSafeBuiltin    wed   as.vector(%2.1, "any")    <str->
  void                    StVar              lW    x, %2.2, e1.2
  cp              %2.4  = Checkpoint                -> BB4 (default) | BB3 (if assume failed)
BB18   <- [1]
  prom-           %18.0 = MkArg                    unboundValue, setdiff[0x55b0cc156510]_p0, e1.2
  val?^           %18.1 = CastType                 up %18.0
  fs              %18.2 = FrameState         R     0x55b0cc5cb250+32: [], env=e1.2
  env             e18.3 = (MkEnv)            l     mode(miss)="any", x=%18.1, parent=R_BaseNamespace, context 0
  fs              %18.4 = FrameState         R     0x55b0cc44f2c0+9: [], env=e18.3, next=%18.2
  fs              %18.5 = FrameState         R     0x55b0cc6892d0+5(pr): [%1.3], env=e1.2, next=%18.4
  void                    Deopt              !v    %18.5   !
BB4   <- [2]
  val?^ | miss    %4.0  = LdVar              eR    as.vector, e1.2
  lgl$#-          %4.1  = Identical                %4.0, function(x, mode="any") <(rir::DispatchTable*)|...
  void                    Assume             D     %4.1, %2.4 (CallTarget@0x55b0cbcb7628[Call#1])
  val?^ | miss    %4.3  = LdVar              eR    y, e1.2
  val?            %4.4  = Force!<lazy>       !v    %4.3, e1.2   <str->
  lgl$#-          %4.5  = IsType                   %4.4 isA val?+
  cp              %4.6  = Checkpoint                -> BB6 (default) | BB5 (if assume failed)
BB3   <- [2]
  fs              %3.0  = FrameState         R     0x55b0cc5cb250+46: [], env=e1.2
  void                    Deopt              !v    %3.0   !
BB6   <- [4]
  void                    Assume             D     %4.5, %4.6 (Typecheck@0x55b0cc3d8ae8[Type#0])
  val?+           %6.1  = CastType           d     dn %4.4   <str->
  val             %6.2  = CallSafeBuiltin    wed   as.vector(%6.1, "any")    <str->
  void                    StVar              lW    y, %6.2, e1.2
  cp              %6.4  = Checkpoint                -> BB8 (default) | BB7 (if assume failed)
BB5   <- [4]
  prom-           %5.0  = MkArg                    unboundValue, setdiff[0x55b0cc156510]_p1, e1.2
  val?^           %5.1  = CastType                 up %5.0
  fs              %5.2  = FrameState         R     0x55b0cc5cb250+78: [], env=e1.2
  env             e5.3  = (MkEnv)            l     mode(miss)="any", x=%5.1, parent=R_BaseNamespace, context 0
  fs              %5.4  = FrameState         R     0x55b0cc44f2c0+9: [], env=e5.3, next=%5.2
  fs              %5.5  = FrameState         R     0x55b0c974b120+5(pr): [%4.4], env=e1.2, next=%5.4
  void                    Deopt              !v    %5.5   !
BB8   <- [6]
  val?^ | miss    %8.0  = LdVar              eR    unique, e1.2
  lgl$#-          %8.1  = Identical                %8.0, function(x, incomparables=FALSE, ...) <(rir::D|...
  void                    Assume             D     %8.1, %6.4 (CallTarget@0x55b0cbcb7628[Call#2])
  val?^ | miss    %8.3  = LdVar              eR    length, e1.2
  lgl$#-          %8.4  = Identical                %8.3, <blt length>
  void                    Assume             D     %8.4, %6.4 (CallTarget@0x55b0cbcb7628[Call#3])
  val?^ | miss    %8.6  = LdVar              eR    x, e1.2
  val?            %8.7  = Force!<value>      !v    %8.6, e1.2   <str->
  val?            %8.8  = CallBuiltin        !v    length(%8.7) e1.2   <int$->
  lgl$-           %8.9  = AsLogical          e     %8.8
  lgl$#-          %8.10 = Identical                %8.9, true
  void                    Branch                   %8.10 -> BB17 (if true) | BB9 (if false)
BB7   <- [6]
  fs              %7.0  = FrameState         R     0x55b0cc5cb250+92: [], env=e1.2
  void                    Deopt              !v    %7.0   !
BB17   <- [8]
  goto BB10
BB9   <- [8]
  prom-           %9.0  = MkArg                    unboundValue, setdiff[0x55b0cc156510]_p19, e1.2
  val?^ | miss    %9.1  = CastType                 up %9.0
  val?            %9.2  = Force              !v    %9.1, e1.2
  val?            %9.3  = CallBuiltin        !v    length(%9.2) e1.2   <val?_>
  lgl$-           %9.4  = AsLogical          e     %9.3
  lgl$-           %9.5  = LOr                      %8.9, %9.4
  goto BB10
BB10   <- [9, 17]
  lgl$-           %10.0 = Phi                      %9.5:BB9, %8.9:BB17
  lgl$#-          %10.1 = CheckTrueFalse     e     %10.0
  void                    Branch                   %10.1 -> BB13 (if true) | BB11 (if false)
BB13   <- [10]
  val?^ | miss    %13.0 = LdVar              eR    x, e1.2
  val?            %13.1 = Force<value>       !v    %13.0, e1.2   <str->
  lgl$#-          %13.2 = IsType                   %13.1 isA val+   <true>
  void                    Branch                   %13.2 -> BB16 (if true) | BB14 (if false)
BB11   <- [10]
  val?^ | miss    %11.0 = LdVar              eR    x, e1.2
  void                    Visible            v     
  val?            %11.2 = Force!             !     %11.0, e1.2   <val?_>
  goto BB12
BB16   <- [13]
  (cls|spec|blt)  %16.0 = LdFun              !v    match, <0x55b0caad1fa0>, e1.2
  prom-           %16.1 = MkArg                    unboundValue, setdiff[0x55b0cc156510]_p20, e1.2
  prom-           %16.2 = MkArg                    unboundValue, setdiff[0x55b0cc156510]_p21, e1.2
  val?            %16.3 = Call               !v    %16.0(%16.1, %16.2, 0L) e1.2   <int->
  val?            %16.4 = Eq                 !v    %16.3, 0L, e1.2   <lgl->
  goto BB15
BB14   <- [13]
  prom-           %14.0 = MkArg                    unboundValue, setdiff[0x55b0cc156510]_p22, e1.2
  goto BB15
BB12   <- [11, 15]
  val?            %12.0 = Phi                      %11.2:BB11, %15.1:BB15
  val?            %12.1 = StaticCall         !     unique[0x55b0cc49d870](%12.0) { 0 } e1.2   <str->
  void                    Return             l     %12.1
BB15   <- [16, 14]
  val?            %15.0 = Phi                      %16.4:BB16, %14.0:BB14
  val?            %15.1 = Extract1_1D        !v    %13.1, %15.0, e1.2   <str->
  void                    Visible            v     
  goto BB12
Prom 0:
BB0
  goto BB1
BB1   <- [0]
  env             e1.0  = LdFunctionEnv            
  val?^ | miss    %1.1  = LdVar              eR    x, e1.0
  void                    Visible            v     
  val?            %1.3  = Force<lazy>        !     %1.1, e1.0   <str->
  void                    Return             l     %1.3
Prom 1:
BB0
  goto BB1
BB1   <- [0]
  env             e1.0  = LdFunctionEnv            
  val?^ | miss    %1.1  = LdVar              eR    y, e1.0
  void                    Visible            v     
  val?            %1.3  = Force<lazy>        !     %1.1, e1.0   <str->
  void                    Return             l     %1.3
Prom 19:
BB0
  goto BB1
BB1   <- [0]
  env             e1.0  = LdFunctionEnv            
  val?^ | miss    %1.1  = LdVar              eR    y, e1.0
  void                    Visible            v     
  val?            %1.3  = Force              !     %1.1, e1.0   <val?_>
  void                    Return             l     %1.3
Prom 20:
BB0
  goto BB1
BB1   <- [0]
  env             e1.0  = LdFunctionEnv            
  val?^ | miss    %1.1  = LdVar              eR    x, e1.0
  void                    Visible            v     
  val?            %1.3  = Force<value>       !     %1.1, e1.0   <str->
  void                    Return             l     %1.3
Prom 21:
BB0
  goto BB1
BB1   <- [0]
  env             e1.0  = LdFunctionEnv            
  val?^ | miss    %1.1  = LdVar              eR    y, e1.0
  void                    Visible            v     
  val?            %1.3  = Force<value>       !     %1.1, e1.0   <str->
  void                    Return             l     %1.3
Prom 22:
BB0
  goto BB1
BB1   <- [0]
  env             e1.0  = LdFunctionEnv            
  (cls|spec|blt)  %1.1  = LdFun              !v    match, e1.0
  prom-           %1.2  = MkArg                    unboundValue, setdiff[0x55b0cc156510]_p23, e1.0
  prom-           %1.3  = MkArg                    unboundValue, setdiff[0x55b0cc156510]_p24, e1.0
  val?            %1.4  = Call               !v    %1.1(%1.2, %1.3, 0L) e1.0   <val?_>
  void                    Visible            v     
  val?            %1.6  = Eq                 !     %1.4, 0L, e1.0   <val?_>
  void                    Return             l     %1.6
Prom 23:
BB0
  goto BB1
BB1   <- [0]
  env             e1.0  = LdFunctionEnv            
  val?^ | miss    %1.1  = LdVar              eR    x, e1.0
  void                    Visible            v     
  val?            %1.3  = Force              !     %1.1, e1.0   <val?_>
  void                    Return             l     %1.3
Prom 24:
BB0
  goto BB1
BB1   <- [0]
  env             e1.0  = LdFunctionEnv            
  val?^ | miss    %1.1  = LdVar              eR    y, e1.0
  void                    Visible            v     
  val?            %1.3  = Force              !     %1.1, e1.0   <val?_>
  void                    Return             l     %1.3

│ setdiff[0x55b0cc156510]                                                      │
└──────────────────────────────────────────────────────────────────────────────┘
